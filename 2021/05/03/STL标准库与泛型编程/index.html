<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="STL,">










<meta name="description" content="STL各组件应用示例STL六大组件STL六大组件包括容器(container)、分配器(allocator)、算法(algorithm)、迭代器(iterator)、适配器(adapter)和仿函数(functor).">
<meta name="keywords" content="STL">
<meta property="og:type" content="article">
<meta property="og:title" content="STL标准库与泛型编程">
<meta property="og:url" content="http://yoursite.com/2021/05/03/STL标准库与泛型编程/index.html">
<meta property="og:site_name" content="邓某的杂货铺">
<meta property="og:description" content="STL各组件应用示例STL六大组件STL六大组件包括容器(container)、分配器(allocator)、算法(algorithm)、迭代器(iterator)、适配器(adapter)和仿函数(functor).">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4qjH.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4o4K.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU479O.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4IN6.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU45Ax.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4H3D.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4bge.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4XDA.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4Oud.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4jHI.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4xEt.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU4zUP.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5ivQ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5S4f.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU59C8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5Pgg.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5C8S.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5ADs.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5kuj.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5Ebn.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5eU0.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5ZEq.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5m5V.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5uCT.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5K8U.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5M2F.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU5Qv4.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/11/gU51KJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1R0r4.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RrZ9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RwMF.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RBqJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RsaR.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RyI1.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RcPx.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1R2RK.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RRxO.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RgG6.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RfMD.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1Rhse.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1R4qH.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/05/07/g1RIZd.png">
<meta property="og:updated_time" content="2021-05-11T10:06:24.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL标准库与泛型编程">
<meta name="twitter:description" content="STL各组件应用示例STL六大组件STL六大组件包括容器(container)、分配器(allocator)、算法(algorithm)、迭代器(iterator)、适配器(adapter)和仿函数(functor).">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/05/11/gU4qjH.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/03/STL标准库与泛型编程/">





  <title>STL标准库与泛型编程 | 邓某的杂货铺</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">邓某的杂货铺</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">凡心所向，素履以往；生如逆旅，一苇以航。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/03/STL标准库与泛型编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Austin Deng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://imgtu.com/i/gw3nYT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邓某的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL标准库与泛型编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-03T19:31:47+08:00">
                2021-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="STL各组件应用示例"><a href="#STL各组件应用示例" class="headerlink" title="STL各组件应用示例"></a>STL各组件应用示例</h1><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>STL六大组件包括<strong>容器</strong>(container)、<strong>分配器</strong>(allocator)、<strong>算法</strong>(algorithm)、<strong>迭代器</strong>(iterator)、<strong>适配器</strong>(adapter)和<strong>仿函数</strong>(functor).</p>
<p><a href="https://imgtu.com/i/gU4qjH" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4qjH.png" alt="gU4qjH.png"></a></p>
<a id="more"></a>
<p>STL中的区间遵循前闭后开的表示方式,迭代器<code>begin</code>指向的是第一个元素的起点,<code>end</code>指向的是最后一个元素的下一个元素.</p>
<p><a href="https://imgtu.com/i/gU4o4K" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4o4K.png" alt="gU4o4K.png"></a></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>STL中的容器大体分为<strong>序列容器</strong>、<strong>关联容器</strong>和<strong>无序容器</strong>.</p>
<p><a href="https://imgtu.com/i/gU479O" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU479O.png" alt="gU479O.png"></a></p>
<p>下面测试程序演示STL中各容器的使用,创建辅助函数如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> ASIZE = <span class="number">500000L</span>;		<span class="comment">// 数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从console中读入一个 long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_a_target_long</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> target = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"target (0~"</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从console中读入一个 string </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get_a_target_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"target (0~"</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="string">"): "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; target;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, target);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较 long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareLongs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">long</span> *) a - *(<span class="keyword">long</span> *) b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较 string</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStrings</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="built_in">string</span> *) a &gt; *(<span class="built_in">string</span> *) b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(<span class="built_in">string</span> *) a &lt; *(<span class="built_in">string</span> *) b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用array"><a href="#使用array" class="headerlink" title="使用array"></a>使用<code>array</code></h3><p>C++11中将数组抽象成了一个模板类<code>array</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // qsort, bsearch, NULL</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_array().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">long</span>, ASIZE&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; ASIZE; ++i) &#123;</span><br><span class="line">        c[i] = rand();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.data()= "</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();</span><br><span class="line"></span><br><span class="line">    timeStart = clock();</span><br><span class="line">    ::qsort(c.data(), ASIZE, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), compareLongs);</span><br><span class="line"><span class="keyword">long</span> *pItem = (<span class="keyword">long</span> *) ::bsearch(&amp;target, (c.data()), ASIZE, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), compareLongs);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"qsort()+bsearch(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test_array()..........</span><br><span class="line">milli-seconds : <span class="number">13</span></span><br><span class="line"><span class="built_in">array</span>.<span class="built_in">size</span>()= <span class="number">500000</span></span><br><span class="line"><span class="built_in">array</span>.front()= <span class="number">28060</span></span><br><span class="line"><span class="built_in">array</span>.back()= <span class="number">25634</span></span><br><span class="line"><span class="built_in">array</span>.data()= <span class="number">0x6a7910</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">20000</span></span><br><span class="line">qsort()+bsearch(), milli-seconds : <span class="number">88</span></span><br><span class="line">found, <span class="number">20000</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用vector"><a href="#使用vector" class="headerlink" title="使用vector"></a>使用<code>vector</code></h3><p><a href="https://imgtu.com/i/gU4IN6" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4IN6.png" alt="gU4IN6.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 		// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  		// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// sort()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vector</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_vector().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 曾經最高 i=58389486 then std::bad_alloc</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.data()= "</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.capacity()= "</span> &lt;&lt; c.capacity() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = clock();</span><br><span class="line">        sort(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sort(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        timeStart = clock();</span><br><span class="line"><span class="built_in">string</span> *pItem = (<span class="built_in">string</span> *) ::bsearch(&amp;target, (c.data()), c.<span class="built_in">size</span>(), <span class="keyword">sizeof</span>(<span class="built_in">string</span>), compareStrings);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"bsearch(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_vector()..........</span><br><span class="line">milli-seconds : <span class="number">211</span></span><br><span class="line"><span class="built_in">vector</span>.max_size()= <span class="number">576460752303423487</span></span><br><span class="line"><span class="built_in">vector</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">vector</span>.front()= <span class="number">30271</span></span><br><span class="line"><span class="built_in">vector</span>.back()= <span class="number">7756</span></span><br><span class="line"><span class="built_in">vector</span>.data()= <span class="number">0x4830040</span></span><br><span class="line"><span class="built_in">vector</span>.capacity()= <span class="number">1048576</span></span><br><span class="line"></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(), milli-seconds : <span class="number">1</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line"></span><br><span class="line">sort(), milli-seconds : <span class="number">2695</span></span><br><span class="line">bsearch(), milli-seconds : <span class="number">1</span></span><br><span class="line">found, <span class="number">23456</span></span><br></pre></td></tr></table></figure></p>
<p><code>vector</code>底层是一段连续的内存空间,当容器满时进行扩容,将容器大小扩容为原来的两倍.</p>
<h3 id="使用list"><a href="#使用list" class="headerlink" title="使用list"></a>使用<code>list</code></h3><p><a href="https://imgtu.com/i/gU45Ax" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU45Ax.png" alt="gU45Ax.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 		// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  		// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; 	// find()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_list</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_list().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//357913941</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">	timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	timeStart = clock();</span><br><span class="line">    c.sort();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.sort(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_list()..........</span><br><span class="line">milli-seconds : <span class="number">406</span></span><br><span class="line"><span class="built_in">list</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">list</span>.max_size()= <span class="number">384307168202282325</span></span><br><span class="line"><span class="built_in">list</span>.front()= <span class="number">31411</span></span><br><span class="line"><span class="built_in">list</span>.back()= <span class="number">7939</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(), milli-seconds : <span class="number">4</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line">c.sort(), milli-seconds : <span class="number">3610</span></span><br></pre></td></tr></table></figure></p>
<p>程序第44行调用的是<code>list</code>类的成员函数<code>sort</code>,而非标准库中的算法<code>sort</code>.这是因为<code>list</code>类本身具有<code>sort</code>方法,容器本身实现的<code>sort</code>的性能一般比标准库中的算法<code>sort</code>更好.</p>
<h3 id="使用forward-list"><a href="#使用forward-list" class="headerlink" title="使用forward_list"></a>使用<code>forward_list</code></h3><p><a href="https://imgtu.com/i/gU4H3D" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4H3D.png" alt="gU4H3D.png"></a></p>
<p><code>forward_list</code>是C++11标准引入的,其前身是gcc中的<code>slist</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 	// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  	// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_forward_list</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_forward_list().......... \n"</span>;</span><br><span class="line"></span><br><span class="line">forward_list &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_front(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"forward_list.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//536870911</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"forward_list.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    timeStart = clock();</span><br><span class="line">    c.sort();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.sort(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_forward_list()..........</span><br><span class="line">milli-seconds : <span class="number">296</span></span><br><span class="line">forward_list.max_size()= <span class="number">461168601842738790</span></span><br><span class="line">forward_list.front()= <span class="number">11513</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(), milli-seconds : <span class="number">9</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line">c.sort(), milli-seconds : <span class="number">3706</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用deque"><a href="#使用deque" class="headerlink" title="使用deque"></a>使用<code>deque</code></h3><p><a href="https://imgtu.com/i/gU4bge" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4bge.png" alt="gU4bge.png"></a></p>
<p><code>deque</code>容器可以再双端插入和删除,其底层是分段连续的,对于使用者来说造成了一种连续的假象.</p>
<p><a href="https://imgtu.com/i/gU4XDA" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4XDA.png" alt="gU4XDA.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 	// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  	// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_deque</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_deque().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    timeStart = clock();</span><br><span class="line">    sort(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sort(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_deque()..........</span><br><span class="line">milli-seconds : <span class="number">170</span></span><br><span class="line"><span class="built_in">deque</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">deque</span>.front()= <span class="number">4080</span></span><br><span class="line"><span class="built_in">deque</span>.back()= <span class="number">29186</span></span><br><span class="line"><span class="built_in">deque</span>.max_size()= <span class="number">576460752303423487</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(), milli-seconds : <span class="number">5</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line">sort(), milli-seconds : <span class="number">2924</span></span><br></pre></td></tr></table></figure>
<p><code>vector</code>容器满时就扩充一个buffer.</p>
<h3 id="使用stack和queue"><a href="#使用stack和queue" class="headerlink" title="使用stack和queue"></a>使用<code>stack</code>和<code>queue</code></h3><p><code>stack</code>和<code>queue</code>底层是通过<code>deque</code>实现的,从设计模式上来说,这两种容器本质上是<code>deque</code>的适配器.</p>
<table>
<thead>
<tr>
<th style="text-align:center">stack</th>
<th style="text-align:center">queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://imgtu.com/i/gU4Oud" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4Oud.png" alt="gU4Oud.png"></a></td>
<td style="text-align:center"><a href="https://imgtu.com/i/gU4jHI" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4jHI.png" alt="gU4jHI.png"></a></td>
</tr>
</tbody>
</table>
<p>这两个容器的元素进出是有严格顺序的,因此<code>stack</code>和<code>queue</code>不支持有关迭代器的操作.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 	// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  	// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_stack</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_stack().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"stack.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"stack.top()= "</span> &lt;&lt; c.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"stack.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"stack.top()= "</span> &lt;&lt; c.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_queue</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_queue().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">300000</span></span><br><span class="line"></span><br><span class="line">test_stack()..........</span><br><span class="line">milli-seconds : <span class="number">57</span></span><br><span class="line"><span class="built_in">stack</span>.<span class="built_in">size</span>()= <span class="number">300000</span></span><br><span class="line"><span class="built_in">stack</span>.top()= <span class="number">17153</span></span><br><span class="line"><span class="built_in">stack</span>.<span class="built_in">size</span>()= <span class="number">299999</span></span><br><span class="line"><span class="built_in">stack</span>.top()= <span class="number">31703</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how many elements:<span class="number">300000</span></span><br><span class="line"></span><br><span class="line">test_queue()..........</span><br><span class="line">milli-seconds : <span class="number">54</span></span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">size</span>()= <span class="number">300000</span></span><br><span class="line"><span class="built_in">queue</span>.front()= <span class="number">6608</span></span><br><span class="line"><span class="built_in">queue</span>.back()= <span class="number">29870</span></span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">size</span>()= <span class="number">299999</span></span><br><span class="line"><span class="built_in">queue</span>.front()= <span class="number">7837</span></span><br><span class="line"><span class="built_in">queue</span>.back()= <span class="number">29870</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用multiset和multimap"><a href="#使用multiset和multimap" class="headerlink" title="使用multiset和multimap"></a>使用<code>multiset</code>和<code>multimap</code></h3><p><a href="https://imgtu.com/i/gU4xEt" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4xEt.png" alt="gU4xEt.png"></a></p>
<p><code>multiset</code>和<code>multimap</code>底层是使用红黑树实现的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 	// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  	// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiset</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_multiset().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multiset.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multiset.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = clock();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);    	<span class="comment">//比 multiset::find(...) 慢很多</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = clock();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);        				<span class="comment">//比 std::find(...) 快很多</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multimap</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_multimap().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            <span class="comment">//multimap 不可使用 [] 做 insertion</span></span><br><span class="line">            c.insert(pair&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt;(i, buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multimap.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multimap.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//178956970</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();</span><br><span class="line">    timeStart = clock();</span><br><span class="line">    <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>multimap</code>支持重复的key,因此不能使用重载的<code>[]</code>运算符进行插入.输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_multiset()..........</span><br><span class="line">milli-seconds : <span class="number">5202</span></span><br><span class="line"><span class="built_in">multiset</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">multiset</span>.max_size()= <span class="number">288230376151711743</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(), milli-seconds : <span class="number">75</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line">c.<span class="built_in">find</span>(), milli-seconds : <span class="number">0</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_multimap()..........</span><br><span class="line">milli-seconds : <span class="number">1423</span></span><br><span class="line"><span class="built_in">multimap</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">multimap</span>.max_size()= <span class="number">256204778801521550</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line">c.<span class="built_in">find</span>(), milli-seconds : <span class="number">0</span></span><br><span class="line">found, value=<span class="number">13328</span></span><br></pre></td></tr></table></figure>
<h3 id="使用unordered-multiset和unordered-multimap"><a href="#使用unordered-multiset和unordered-multimap" class="headerlink" title="使用unordered_multiset和unordered_multimap"></a>使用<code>unordered_multiset</code>和<code>unordered_multimap</code></h3><p><a href="https://imgtu.com/i/gU4zUP" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU4zUP.png" alt="gU4zUP.png"></a></p>
<p><code>unordered_multiset</code>和<code>unordered_multimap</code>底层是使用hash+链表实现的.</p>
<p><code>unordered_multiset</code>和<code>unordered_multimap</code>的元素个数小于篮子数目,若元素数目达到篮子个数,则容器扩容,将篮子数组扩充约一倍.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; 	// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  	// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_multiset</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_unordered_multiset().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_multiset</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//357913941</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.bucket_count()= "</span> &lt;&lt; c.bucket_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.load_factor()= "</span> &lt;&lt; c.load_factor() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.max_load_factor()= "</span> &lt;&lt; c.max_load_factor() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.max_bucket_count()= "</span> &lt;&lt; c.max_bucket_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"bucket #"</span> &lt;&lt; i &lt;&lt; <span class="string">" has "</span> &lt;&lt; c.bucket_size(i) &lt;&lt; <span class="string">" elements.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = clock();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);    <span class="comment">//比 unordered_multiset::find() 慢很多</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = clock();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);        <span class="comment">//比 std::find() 快很多</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_multimap</span><span class="params">(<span class="keyword">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_unordered_multimap().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_multimap</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            <span class="comment">//multimap 不可使用 [] 進行 insertion</span></span><br><span class="line">            c.insert(pair&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt;(i, buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multimap.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multimap.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();</span><br><span class="line">    timeStart = clock();</span><br><span class="line">    <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_unordered_multiset()..........</span><br><span class="line">milli-seconds : <span class="number">1476</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>.max_size()= <span class="number">384307168202282325</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>.bucket_count()= <span class="number">1832561</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>.load_factor()= <span class="number">0.545684</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>.max_load_factor()= <span class="number">1</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>.max_bucket_count()= <span class="number">384307168202282325</span></span><br><span class="line">bucket #<span class="number">0</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">1</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">2</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">3</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">4</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">5</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">6</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">7</span> has <span class="number">34</span> elements.</span><br><span class="line">bucket #<span class="number">8</span> has <span class="number">0</span> elements.</span><br><span class="line">bucket #<span class="number">9</span> has <span class="number">0</span> elements.</span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(), milli-seconds : <span class="number">104</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line">c.<span class="built_in">find</span>(), milli-seconds : <span class="number">1</span></span><br><span class="line">found, <span class="number">23456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how many elements:<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">test_unordered_multimap()..........</span><br><span class="line">milli-seconds : <span class="number">1051</span></span><br><span class="line"><span class="built_in">unordered_multimap</span>.<span class="built_in">size</span>()= <span class="number">1000000</span></span><br><span class="line"><span class="built_in">unordered_multimap</span>.max_size()= <span class="number">384307168202282325</span></span><br><span class="line">target (<span class="number">0</span>~<span class="number">32767</span>):<span class="number">23456</span></span><br><span class="line"> c.<span class="built_in">find</span>(), milli-seconds : <span class="number">0</span></span><br><span class="line">found, value=<span class="number">20464</span></span><br></pre></td></tr></table></figure></p>
<h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>STL容器默认的分配器是<code>std::allocator</code>,除此之外gcc额外定义了几个分配器,其头文件均在目录<code>ext</code>下.</p>
<p><a href="https://imgtu.com/i/gU5ivQ" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5ivQ.png" alt="gU5ivQ.png"></a></p>
<p>gcc额外定义的分配器均位于<code>__gnu_cxx</code>命名空间下.分配器一般用于构建容器,不会直接使用.因为分配器想要直接使用也不好用(使用<code>free</code>关键字时不需要指定回收内存的大小,而分配器的<code>deallocate</code>函数需要指定回收内存大小).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;		// abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;		// snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// find()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;    //內含 std::allocator</span></span></span><br><span class="line"><span class="comment">//欲使用 std::allocator 以外的 allocator,得自行 #include &lt;ext\...&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\array_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\mt_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\debug_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\pool_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\bitmap_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\malloc_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\new_allocator.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pass A object to function template impl()，</span></span><br><span class="line"><span class="comment">//而 A 本身是個 class template, 帶有 type parameter T,</span></span><br><span class="line"><span class="comment">//那麼有無可能在 impl() 中抓出 T, 創建一個 list&lt;T, A&lt;T&gt;&gt; object?</span></span><br><span class="line"><span class="comment">//以下先暫時迴避上述疑問.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_list_with_special_allocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_list_with_special_allocator().......... \n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能在 switch case 中宣告，只好下面這樣. 				  	// 1000000次</span></span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="built_in">string</span>, allocator&lt;<span class="built_in">string</span>&gt;&gt; c1;                   	<span class="comment">// 3140</span></span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="built_in">string</span>, __gnu_cxx::malloc_allocator&lt;<span class="built_in">string</span>&gt;&gt; c2; 	<span class="comment">// 3110</span></span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="built_in">string</span>, __gnu_cxx::new_allocator&lt;<span class="built_in">string</span>&gt;&gt; c3;		<span class="comment">// 3156</span></span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="built_in">string</span>, __gnu_cxx::__pool_alloc&lt;<span class="built_in">string</span>&gt;&gt; c4;     	<span class="comment">// 4922</span></span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="built_in">string</span>, __gnu_cxx::__mt_alloc&lt;<span class="built_in">string</span>&gt;&gt; c5;        <span class="comment">// 3297</span></span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="built_in">string</span>, __gnu_cxx::bitmap_allocator&lt;<span class="built_in">string</span>&gt;&gt; c6; 	<span class="comment">// 4781</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"select: "</span></span><br><span class="line">        &lt;&lt; <span class="string">" (1) std::allocator "</span></span><br><span class="line">        &lt;&lt; <span class="string">" (2) malloc_allocator "</span></span><br><span class="line">        &lt;&lt; <span class="string">" (3) new_allocator "</span></span><br><span class="line">        &lt;&lt; <span class="string">" (4) __pool_alloc "</span></span><br><span class="line">        &lt;&lt; <span class="string">" (5) __mt_alloc "</span></span><br><span class="line">        &lt;&lt; <span class="string">" (6) bitmap_allocator "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">    <span class="keyword">if</span> (choice != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"how many elements: "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, i);</span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">                    c1.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">                    c2.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line">                    c3.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> :</span><br><span class="line">                    c4.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span> :</span><br><span class="line">                    c5.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span> :</span><br><span class="line">                    c6.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exception &amp;p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a lot of push_back(), milli-seconds : "</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test all allocators' allocate() &amp; deallocate();</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    allocator&lt;<span class="keyword">int</span>&gt; alloc1;</span><br><span class="line">    p = alloc1.allocate(<span class="number">1</span>);</span><br><span class="line">    alloc1.deallocate(p, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    __gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt; alloc2;</span><br><span class="line">    p = alloc2.allocate(<span class="number">1</span>);</span><br><span class="line">    alloc2.deallocate(p, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    __gnu_cxx::new_allocator&lt;<span class="keyword">int</span>&gt; alloc3;</span><br><span class="line">    p = alloc3.allocate(<span class="number">1</span>);</span><br><span class="line">    alloc3.deallocate(p, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt; alloc4;</span><br><span class="line">    p = alloc4.allocate(<span class="number">2</span>);</span><br><span class="line">    alloc4.deallocate(p, <span class="number">2</span>);    <span class="comment">//我刻意令參數為 2, 但這有何意義!! 一次要 2 個 ints?</span></span><br><span class="line"></span><br><span class="line">    __gnu_cxx::__mt_alloc&lt;<span class="keyword">int</span>&gt; alloc5;</span><br><span class="line">    p = alloc5.allocate(<span class="number">1</span>);</span><br><span class="line">    alloc5.deallocate(p, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    __gnu_cxx::bitmap_allocator&lt;<span class="keyword">int</span>&gt; alloc6;</span><br><span class="line">    p = alloc6.allocate(<span class="number">3</span>);</span><br><span class="line">    alloc6.deallocate(p, <span class="number">3</span>);    <span class="comment">//我刻意令參數為 3, 但這有何意義!! 一次要 3 個 ints?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL容器源码分析"><a href="#STL容器源码分析" class="headerlink" title="STL容器源码分析"></a>STL容器源码分析</h1><h2 id="STL设计模式-OOP和GP"><a href="#STL设计模式-OOP和GP" class="headerlink" title="STL设计模式:OOP和GP"></a>STL设计模式:OOP和GP</h2><p>OOP(Object-Oriented Programming)和GP(Generic Programming)是STL容器设计中使用的两种设计模式.</p>
<ul>
<li>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起,例如对<code>std::list</code>容器进行排序要调用<code>std::list::sort</code>方法.</li>
<li>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来,例如对<code>std::vector</code>容器进行排序要调用<code>std::sort</code>方法.</li>
</ul>
<p>这种不同是因为<code>std::sort</code>方法内部调用了<code>iterator</code>的<code>-</code>运算,<code>std::list</code>的<code>iterator</code>没有实现<code>-</code>运算符,而<code>std::vector</code>的<code>iterator</code>实现了<code>-</code>运算符.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">        <span class="built_in">std</span>::__introsort_loop(__first, __last,</span><br><span class="line">                              <span class="built_in">std</span>::__lg(__last - __first) * <span class="number">2</span>,		<span class="comment">// 对iterator进行减运算,std::list的iterator没有实现该运算</span></span><br><span class="line">                              __comp);</span><br><span class="line">        <span class="built_in">std</span>::__final_insertion_sort(__first, __last, __comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载与模板特化"><a href="#运算符重载与模板特化" class="headerlink" title="运算符重载与模板特化"></a>运算符重载与模板特化</h2><p>实现STL的两大基础就是<strong>运算符重载</strong>和<strong>模板特化</strong>.</p>
<p><a href="https://imgtu.com/i/gU5S4f" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5S4f.png" alt="gU5S4f.png"></a></p>
<h2 id="分配器-1"><a href="#分配器-1" class="headerlink" title="分配器"></a>分配器</h2><p>VC6.0的默认分配器<code>std::allocator</code>定义如下,可以看到VC6.0的分配器只是对<code>::operator new</code>和<code>::operator delete</code>的简单封装.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="keyword">const</span> <span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_Allocate((difference_type) _N，(pointer) <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> _FARQ *_P, size_type)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_P)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> _Ty _FARQ *_Allocate(_PDFT _N, _Ty _FARQ *) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_N &lt; <span class="number">0</span>) _N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ((_Ty _FARQ *) <span class="keyword">operator</span> <span class="keyword">new</span>((_SIZT) _N * <span class="keyword">sizeof</span>(_Ty)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>gcc2.9中的分配器<code>std::allocator</code>与VC6.0的实现类似,但<code>std::allocator</code>并非gcc2.9的默认分配器,观察容器源码,可以看到,gcc2.9的默认分配器为<code>std::alloc</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::alloc</code>的代码结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; _S_align = <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; _S_max_bytes = <span class="number">128</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; _S_free_list_size = (<span class="keyword">size_t</span>) _S_max_bytes / (<span class="keyword">size_t</span>) _S_align &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> _Obj &#123;</span><br><span class="line">        <span class="keyword">union</span> _Obj *_M_free_list_link;</span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">// The client sees this.</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::alloc</code>内部维护一个链表数组,数组中的每个链表保存某个尺寸的对象,减少了调用<code>malloc</code>的次数,从而减小了<code>malloc</code>带来的额外开销.</p>
<p><a href="https://imgtu.com/i/gU59C8" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU59C8.png" alt="gU59C8.png"></a></p>
<p>在gcc4.9以后,默认分配器变为<code>std::allocator</code>,变回了对<code>::operator new</code>和<code>::operator delete</code>的简单封装.gcc2.9中的<code>std::alloc</code>更名为<code>__gnu_cxx::__pool_alloc</code>.</p>
<h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><p>STL容器的各实现类关系如下图所示,以缩排形式表示衍生关系(主要是<strong>复合关系</strong>).</p>
<p><a href="https://imgtu.com/i/gU5Pgg" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5Pgg.png" alt="gU5Pgg.png"></a></p>
<h3 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器<code>list</code></h3><p>gcc2.9中<code>list</code>及相关类的代码如下所示:</p>
<p><a href="https://imgtu.com/i/gU5C8S" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5C8S.png" alt="gU5C8S.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node *link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T &amp;, T *&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为实现前闭后开的特性,在环形链表末尾加入一个用以占位的空节点,并将迭代器<code>list::end()</code>指向该节点.</p>
<p><a href="https://imgtu.com/i/gU5ADs" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5ADs.png" alt="gU5ADs.png"></a></p>
<p>迭代器<code>__list_iterator</code>重载了指针的<code>*</code>,<code>-&gt;</code>,<code>++</code>,<code>--</code>等运算符,并定义了<code>iterator_category</code>、<code>value_type</code>、<code>difference_type</code>、<code>pointer</code>和<code>reference</code>5个<strong>关联类型</strong>(associated types),这些特征将被STL算法使用.</p>
<p><a href="https://imgtu.com/i/gU5kuj" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5kuj.png" alt="gU5kuj.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag 	iterator_category; 	<span class="comment">// 关联类型1</span></span><br><span class="line">    <span class="keyword">typedef</span> T 							value_type;			<span class="comment">// 关联类型2</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> 					difference_type;	<span class="comment">// 关联类型3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr 						pointer;			<span class="comment">// 关联类型4</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref 						reference;			<span class="comment">// 关联类型5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __list_node &lt;T&gt;*			link_type;</span><br><span class="line">    link_type node;		<span class="comment">// 指向的链表节点</span></span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        node = (link_type) ((*node).next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意在这里前置<code>++</code>运算符返回左值,而后置<code>++</code>返回右值,这与基础类型的<code>++</code>和<code>--</code>运算一致.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">i++++;		<span class="comment">// 被解析为 ++(++i), 能通过编译</span></span><br><span class="line">++++i;		<span class="comment">// 被解析为 (i++)++, 不能通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line"><span class="keyword">auto</span> ite = c.<span class="built_in">begin</span>();</span><br><span class="line">++++ite;	<span class="comment">// 被解析为 ++(++ite), 能通过编译</span></span><br><span class="line">ite++++;	<span class="comment">// 被解析为 (ite++)++, 不能通过编译</span></span><br></pre></td></tr></table></figure>
<p>在gcc4.9以后,<code>list</code>相关的类使用了继承,增加了不必要的复杂度.</p>
<p>STL的算法传入的参数的一般是迭代器或指针,在算法内部,需要根据传入的迭代器或指针推断出迭代器的<strong>关联类型</strong>(associated types).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _ForwardIterator <span class="title">rotate</span><span class="params">(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__rotate(__first, __middle, __last, <span class="built_in">std</span>::__iterator_category(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::iterator_category </span><br><span class="line">__iterator_category(<span class="keyword">const</span> _Iter &amp;) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::iterator_category(); 	<span class="comment">// 推断迭代器的关联类型 iterator_category</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/gU5Ebn" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5Ebn.png" alt="gU5Ebn.png"></a></p>
<p>迭代器的5个关联类型在类中均有定义,但是指针类型的关联类型需要根据指针类别进行确定,为了使STL算法同时兼容迭代器和一般指针,就在迭代器(指针)和算法之间加一个中间层<strong>萃取器</strong>(traits).</p>
<p>迭代器萃取器<code>iterator_traits</code>能够兼容迭代器和一般指针,获取其5个关联类型:<code>iterator_category</code>、<code>value_type</code>、<code>difference_type</code>、<code>pointer</code>和<code>reference</code>.</p>
<p><a href="https://imgtu.com/i/gU5eU0" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5eU0.png" alt="gU5eU0.png"></a></p>
<p>在实现上,<code>iterator_traits</code>类使用模板的偏特化,对于一般的迭代器类型,直接取迭代器内部定义的关联类型;对于指针和常量指针进行偏特化,指定关联类型的值.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对一般的迭代器类型,直接取迭代器内定义的关联类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category 	iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type 			value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type 	difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer 			pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference 			reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对指针类型进行特化,指定关联类型的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T *&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag 		iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T 								value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> 						difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*								pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;								reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对指针常量类型进行特化,指定关联类型的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T *&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag 		iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T 								value_type;		<span class="comment">// value_tye被用于创建变量,为灵活起见,取 T 而非 const T 作为 value_type</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> 						difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T*						pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;						reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>想要在算法内获取关联类型的值,只需像下面这样写:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器vector"><a href="#容器vector" class="headerlink" title="容器vector"></a>容器<code>vector</code></h3><p>容器<code>vector</code>的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>= <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/gU5ZEq" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5ZEq.png" alt="gU5ZEq.png"></a></p>
<p>容器<code>vector</code>的迭代器<code>start</code>指向第一个元素,迭代器<code>finish</code>指向最后一个元素的下一个元素,这两个迭代器对应<code>begin()</code>和<code>end()</code>的返回值,维持了<strong>前闭后开</strong>的特性.</p>
<p><code>vector</code>对使用者是连续的,因此重载了<code>[]</code>运算符.</p>
<p><code>vector</code>的实现也是连续的,因此使用指针类型做迭代器(即迭代器<code>vector&lt;T&gt;::iterator</code>的实际类型是原生指针<code>T*</code>).</p>
<p><code>vector::push_back</code>方法先判断内存空间是否满,若内存空间不满则直接插入;若内存空间满则调用<code>insert_aux</code>函数先扩容两倍再插入元素.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123; <span class="comment">// 尚有备用空间,则直接插入,并调整finish迭代器</span></span><br><span class="line">        construct(finish, x);		</span><br><span class="line">        ++finish;					</span><br><span class="line">    &#125; <span class="keyword">else</span> 							<span class="comment">// 已无备用空间则调用 insert_aux 先扩容再插入元素</span></span><br><span class="line">        insert_aux(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>insert_aux</code>被设计用于在容器任意位置插入元素,在容器内存空间不足会现将原有容器扩容.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_ux(iterator <span class="built_in">position</span>, <span class="keyword">const</span> T &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;     <span class="comment">// 尚有备用空间,则将插入点后元素后移一位并插入元素</span></span><br><span class="line">        construct(finish, *(finish - <span class="number">1</span>));   <span class="comment">// 以vector最后一个元素值为新节点的初值</span></span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        copy_backward(<span class="built_in">position</span>, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *<span class="built_in">position</span> = x_copy;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已无备用空间,则先扩容,再插入</span></span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ?: <span class="number">2</span> * old_size:<span class="number">1</span>;  <span class="comment">// 扩容后长度为原长度的两倍</span></span><br><span class="line"></span><br><span class="line">        iterator new_start = data_allocator::allocate(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            new_finish = uninitialized_copy(start, <span class="built_in">position</span>, new_start);    <span class="comment">// 拷贝插入点前的元素</span></span><br><span class="line">            construct(new_finish, x);                                       <span class="comment">// 插入新元素并调整水位</span></span><br><span class="line">            ++new_finish;</span><br><span class="line">            new_finish = uninitialized_copy(<span class="built_in">position</span>, finish, new_finish);  <span class="comment">// 拷贝插入点后的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 插入失败则回滚,释放内存并抛出错误</span></span><br><span class="line">            destroy(new_start, new_finish) :</span><br><span class="line">            data_allocator::deallocate(new_start, len);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放原容器所占内存</span></span><br><span class="line">        destroy(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="comment">// 调整迭代器</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器<code>array</code></h3><p>将数组封装成容器<code>array</code>是为了使之与STL算法兼容,其内部实现只是简单封装了一下数组,甚至没有构造函数和析构函数.与<code>vector</code>一样使用原生指针做迭代器.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type *iterator;</span><br><span class="line"></span><br><span class="line">    value_type _M_instance[_Nm ? _Nm : <span class="number">1</span>];	<span class="comment">// Support for zero-sized arrays mandatory</span></span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="容器deque"><a href="#容器deque" class="headerlink" title="容器deque"></a>容器<code>deque</code></h3><p>容器<code>deque</code>内部是分段连续的,对使用者表现为连续的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> =<span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _deque_iterator&lt;T, T &amp;, T *, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer *map_pointer;   <span class="comment">// T**</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    map_pointer <span class="built_in">map</span>;		<span class="comment">// 控制中心,数组中每个元素指向一个buffer</span></span><br><span class="line">    size_type map_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>deque::map</code>的类型为二重指针<code>T**</code>,称为<strong>控制中心</strong>,其中每个元素指向一个buffer.</p>
<p><a href="https://imgtu.com/i/gU5m5V" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5m5V.png" alt="gU5m5V.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// 定义5个关联类型</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag	iterator_category; 	<span class="comment">// 关联类型1</span></span><br><span class="line">    <span class="keyword">typedef</span> T 							value_type;       	<span class="comment">// 关联类型2</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> 					difference_type;	<span class="comment">// 关联类型3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr 						pointer;			<span class="comment">// 关联类型4</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref 						reference;			<span class="comment">// 关联类型5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T **map_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器核心字段:4个指针</span></span><br><span class="line">    T *cur;     		<span class="comment">// 指向当前元素</span></span><br><span class="line">    T *first;   		<span class="comment">// 指向当前buffer的开始</span></span><br><span class="line">    T *last;    		<span class="comment">// 指向当前buffer的末尾</span></span><br><span class="line">    map_pointer node;   <span class="comment">// 指向控制中心</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代器<code>deque::iterator</code>的核心字段是4个指针:<code>cur</code>指向当前元素、<code>first</code>和<code>last</code>分别指向当前buffer的开始和末尾、<code>node</code>指向控制中心.</p>
<p><code>deque::insert</code>方法先判断插入元素在容器的前半部分还是后半部分,再将数据往比较短的那一半推.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">position</span>.cur == start.cur) &#123;        	<span class="comment">// 若插入位置是容器首部,则直接push_front</span></span><br><span class="line">        push_front(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">position</span>.cur == finish.cur) &#123;	<span class="comment">// 若插入位置是容器尾部,则直接push_back</span></span><br><span class="line">        push_back(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> insert_aux(<span class="built_in">position</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type &amp;x) &#123;</span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// 插入点前的元素数</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;    	  		<span class="comment">// 1. 如果插入点前的元素数较少,则将前半部分元素向前推</span></span><br><span class="line">        push_front(front());        		<span class="comment">// 1.1. 在容器首部创建元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        copy(front2, pos1, front1); 		<span class="comment">// 1.2. 将前半部分元素左移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                        		<span class="comment">// 2. 如果插入点后的元素数较少,则将后半部分元素向后推</span></span><br><span class="line">        push_back(back());          		<span class="comment">// 2.1. 在容器末尾创建元素</span></span><br><span class="line">        copy_backward(pos, back2, back1); 	<span class="comment">// 2.2. 将后半部分元素右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;		<span class="comment">// 3. 在插入位置上放入元素</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器<code>deque::iterator</code>模拟空间的连续性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// 迭代器核心字段:4个指针</span></span><br><span class="line">    T *cur;            	<span class="comment">// 指向当前元素</span></span><br><span class="line">    T *first;        	<span class="comment">// 指向当前buffer的开始</span></span><br><span class="line">    T *last;            <span class="comment">// 指向当前buffer的末尾</span></span><br><span class="line">    map_pointer node;   <span class="comment">// 指向控制中心</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +	<span class="comment">// 两根迭代器间的长度</span></span><br><span class="line">               (cur - first) +      								<span class="comment">// 当前迭代器到当前buffer末尾的长度</span></span><br><span class="line">               (x.last - x.cur);    								<span class="comment">// 迭代器x到其buffer首部的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++cur;				<span class="comment">// 切换至下一元素</span></span><br><span class="line">        <span class="keyword">if</span> (cur == last) &#123; 	<span class="comment">// 若到达buffer末尾,则跳转至下一buffer的起点</span></span><br><span class="line">            set_node(node + <span class="number">1</span>);</span><br><span class="line">            cur = first; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123; 	<span class="comment">// 设置当前元素所在的buffer为new_node</span></span><br><span class="line">        node = new_node;</span><br><span class="line">        first = *new_node;</span><br><span class="line">        last = first + difference_type(buffer_size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self &amp;<span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">        difference_type offset = n + (cur - first);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))	</span><br><span class="line">            <span class="comment">// 若目标位置在同一buffer内,则直接跳转</span></span><br><span class="line">            cur += n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 若目标位置不在同一buffer内,则先切换buffer,再在buffer内寻址</span></span><br><span class="line">            difference_type node_offset = </span><br><span class="line">                offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())</span><br><span class="line">                               : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;</span><br><span class="line">            set_node(node + node_offset);</span><br><span class="line">            cur = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self &amp;<span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"></span><br><span class="line">    self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp -= n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="容器queue和stack"><a href="#容器queue和stack" class="headerlink" title="容器queue和stack"></a>容器<code>queue</code>和<code>stack</code></h3><table>
<thead>
<tr>
<th style="text-align:center">stack</th>
<th style="text-align:center">queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://imgtu.com/i/gU5uCT" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5uCT.png" alt="gU5uCT.png"></a></td>
<td style="text-align:center"><a href="https://imgtu.com/i/gU5K8U" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5K8U.png" alt="gU5K8U.png"></a></td>
</tr>
</tbody>
</table>
<p>容器<code>queue</code>和<code>stack</code>作为<code>deque</code>的适配器(adapter),其内部均默认封装了一个<code>deque</code>作为底层容器,通过该<code>deque</code>执行具体操作.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>=<span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;     <span class="comment">// 底层容器,默认是deque&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type &amp;x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_front(); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>=<span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;<span class="comment">// 底层容器,默认是deque&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type &amp;x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_back(); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>容器<code>queue</code>和<code>stack</code>的元素进出是严格有序的,因此两个容器都不允许遍历,其内部没有定义<code>iterator</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;	<span class="comment">// 不能通过编译 error: 'iterator' is not a member of 'std::stack&lt;std::__cxx11::basic_string&lt;char&gt; &gt;'</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;	<span class="comment">// 不能通过编译 error: 'iterator' is not a member of 'std::queue&lt;std::__cxx11::basic_string&lt;char&gt; &gt;'</span></span><br></pre></td></tr></table></figure>
<p>实际上<code>queue</code>和<code>stack</code>的底层容器也可以指定为<code>list</code>;<code>stack</code>的底层容器也可以指定为<code>vector</code>,这些底层容器均实现了<code>queue</code>和<code>stack</code>内部用到的方法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; q1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    q1.push(rand());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; s1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    s1.push(rand());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    s2.push(rand());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上,若指定了错误的底层容器但没有调用不支持的方法的话,程序仍能够编译通过,这说明编译器在处理模板时不会做全面的检查.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    q2.push(rand());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.size()= "</span> &lt;&lt; q2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.front()= "</span> &lt;&lt; q2.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.back()= "</span> &lt;&lt; q2.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 若注释掉下面一行,则程序能够编译通过</span></span><br><span class="line">q2.pop();	<span class="comment">// error: 'class std::vector&lt;int&gt;' has no member named 'pop_front'</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.size()="</span> &lt;&lt; q2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.front()= "</span> &lt;&lt; q2.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"queue.back()= "</span> &lt;&lt; q2.back() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="容器rbtree"><a href="#容器rbtree" class="headerlink" title="容器rbtree"></a>容器<code>rbtree</code></h3><p>容器<code>rb_tree</code>封装了红黑树,是有序容器,提供了迭代器iterator用以遍历,但不应使用iterator直接改变元素值(虽然编程层面并没有禁止这样做).</p>
<p><code>rb_tree</code>提供两种插入操作:<code>insert_unique</code>和<code>insert_equal</code>,前者表示节点的<code>key</code>一定在整棵树中独一无二,否则插入失败;后者表示节点的<code>key</code>可重复.</p>
<p>对于<code>rb_tree</code>,定义一个概念:节点的<code>value</code>包括其<code>key</code>和<code>data</code>,这里的<code>data</code>表示一般说法中的<code>value</code>.</p>
<p><a href="https://imgtu.com/i/gU5M2F" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5M2F.png" alt="gU5M2F.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,				// 指定<span class="title">key</span>类型</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Value</span>,			// 指定<span class="title">Value</span>类型</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">KeyOfValue</span>,		// 仿函数类,指定从<span class="title">Value</span>中获取<span class="title">Key</span>的方式</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Compare</span>,			// 仿函数类,指定<span class="title">Key</span>的排序方式</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node &lt;Value&gt; rb_tree_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node *link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type node_count;	<span class="comment">// rb_tree的大小(节点数量)</span></span><br><span class="line">    link_type header;		<span class="comment">// 头节点</span></span><br><span class="line">    Compare key_compare; 	<span class="comment">// Key的排序方式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>rb_tree</code>的<code>header</code>指向一个多余的空节点,用以维持其前闭后开的特性.</p>
<p><a href="https://imgtu.com/i/gU5Qv4" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU5Qv4.png" alt="gU5Qv4.png"></a></p>
<p>下面程序演示<code>rb_tree</code>的使用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; itree;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.empty() &lt;&lt; <span class="built_in">endl</span>; 	<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>; 	<span class="comment">// 0</span></span><br><span class="line">itree.insert_unique(<span class="number">3</span>);</span><br><span class="line">itree.insert_unique(<span class="number">8</span>);</span><br><span class="line">itree.insert_unique(<span class="number">5</span>);</span><br><span class="line">itree.insert_unique(<span class="number">9</span>);</span><br><span class="line">itree.insert_unique(<span class="number">13</span>);</span><br><span class="line">itree.insert_unique(<span class="number">5</span>); 		<span class="comment">//no effect, since using insert_unique()</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.empty() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.count(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//1</span></span><br><span class="line">itree.insert_equal(<span class="number">5</span>);</span><br><span class="line">itree.insert_equal(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>; 	<span class="comment">//7, since using insert_equal()</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itree.count(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="容器set和multiset"><a href="#容器set和multiset" class="headerlink" title="容器set和multiset"></a>容器<code>set</code>和<code>multiset</code></h3><p>容器<code>set</code>和<code>multiset</code>以<code>rb_tree</code>为底层容器,因此其中元素是有序的,排序的依据是<code>key</code>.<code>set</code>和<code>multiset</code>元素的<code>value</code>和<code>key</code>一致.</p>
<p><code>set</code>和<code>multiset</code>提供迭代器<code>iterator</code>用以顺序遍历容器,但无法使用<code>iterator</code>改变元素值,因为<code>set</code>和<code>multiset</code>使用的是内部<code>rb_tree</code>的<code>const_iterator</code>.</p>
<p><code>set</code>元素的<code>key</code>必須独一无二,因此其<code>insert()</code>调用的是内部<code>rb_tree</code>的<code>insert_unique()</code>方法;<code>multiset</code>元素的<code>key</code>可以重复,因此其<code>insert()</code>调用的是内部<code>rb_tree</code>的<code>insert_equal()</code>方法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree &lt;key_type, </span><br><span class="line">    				 value_type, </span><br><span class="line">    				 identity&lt;value_type&gt;, </span><br><span class="line">    				 key_compare, </span><br><span class="line">    				 Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;		<span class="comment">// 内部rb_tree容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>set</code>容器的模板参数推导过程如下:</p>
<p><a href="https://imgtu.com/i/gU51KJ" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/11/gU51KJ.png" alt="gU51KJ.png"></a></p>
<h3 id="容器map和multimap"><a href="#容器map和multimap" class="headerlink" title="容器map和multimap"></a>容器<code>map</code>和<code>multimap</code></h3><p>容器<code>map</code>和<code>multimap</code>以<code>rb_tree</code>为底层容器,因此其中元素是有序的,排序的依据是<code>key</code>.</p>
<p><code>map</code>和<code>multimap</code>提供迭代器<code>iterator</code>用以顺序遍历容器.无法使用<code>iterator</code>改变元素的<code>key</code>,但可以用它来改变元素的<code>data</code>,因为<code>map</code>和<code>multimap</code>内部自动将<code>key</code>的类型设为<code>const</code>.</p>
<p><code>map</code>元素的<code>key</code>必須独一无二,因此其<code>insert()</code>调用的是内部<code>rb_tree</code>的<code>insert_unique()</code>方法;<code>multimap</code>元素的<code>key</code>可以重复,因此其<code>insert()</code>调用的是内部<code>rb_tree</code>的<code>insert_equal()</code>方法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree &lt;key_type, </span><br><span class="line">    				 value_type, </span><br><span class="line">    				 select1st&lt;value_type&gt;, </span><br><span class="line">    				 key_compare, </span><br><span class="line">    				 Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;		<span class="comment">// 内部rb_tree容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator)</span><br><span class="line">    iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>map</code>容器的模板参数推导过程如下:</p>
<p><a href="https://imgtu.com/i/g1R0r4" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1R0r4.png" alt="g1R0r4.png"></a></p>
<p><code>map</code>容器重载的<code>[]</code>运算符返回对应<code>data</code>的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mapped_type&amp; <span class="keyword">operator</span>[](key_type&amp;&amp; __k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先查找key</span></span><br><span class="line">    <span class="comment">// 若key存在,则直接返回其data的引用</span></span><br><span class="line">	iterator __i = lower_bound(__k);</span><br><span class="line">    <span class="comment">// 若key不存在,则先插入key,再返回对应的引用</span></span><br><span class="line">    <span class="keyword">if</span> (__i == <span class="built_in">end</span>() || key_comp()(__k, (*__i).first))</span><br><span class="line">        __i = _M_t._M_emplace_hint_unique(__i, <span class="built_in">std</span>::piecewise_construct, <span class="built_in">std</span>::forward_as_tuple(<span class="built_in">std</span>::<span class="built_in">move</span>(__k)), <span class="built_in">std</span>::tuple&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> (*__i).second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器hashtable"><a href="#容器hashtable" class="headerlink" title="容器hashtable"></a>容器<code>hashtable</code></h3><p><a href="https://imgtu.com/i/g1RrZ9" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RrZ9.png" alt="g1RrZ9.png"></a></p>
<p><code>hashtable</code>最开始只有53个桶,当元素个数大于桶的个数时,桶的数目扩大为最接近当前桶数两倍的质数,实际上,桶数目的增长顺序被写死在代码里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] = &#123;</span><br><span class="line">        <span class="number">53</span>, <span class="number">97</span>, <span class="number">193</span>, <span class="number">389</span>, <span class="number">769</span>, <span class="number">1543</span>, <span class="number">3079</span>, <span class="number">6151</span>, <span class="number">12289</span>, <span class="number">24593</span>,</span><br><span class="line">        <span class="number">49157</span>, <span class="number">98317</span>, <span class="number">196613</span>, <span class="number">393241</span>, <span class="number">786433</span>, <span class="number">1572869</span>, <span class="number">3145739</span>,</span><br><span class="line">        <span class="number">6291469</span>, <span class="number">12582917</span>, <span class="number">25165843</span>, <span class="number">50331653</span>, <span class="number">100663319</span>,</span><br><span class="line">        <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>, <span class="number">1610612741</span>,</span><br><span class="line">        <span class="number">3221225473u</span>l, <span class="number">4294967291u</span>l&#125;;</span><br></pre></td></tr></table></figure>
<p><code>hashtable</code>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, </span></span><br><span class="line"><span class="class">		 <span class="title">class</span> <span class="title">Key</span>, </span></span><br><span class="line"><span class="class">		 <span class="title">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">ExtractKey</span>, </span></span><br><span class="line"><span class="class">		 <span class="title">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloC</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn 	hasher;</span><br><span class="line">    <span class="keyword">typedef</span> EqualKey 	key_equal;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> 		size_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    hasher hash;</span><br><span class="line">    key_equal equals;</span><br><span class="line">    ExtractKey get_key;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node*, Alloc&gt; buckets;	<span class="comment">// 保存桶的vector</span></span><br><span class="line">    size_type num_elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">hashtable_node</span> &#123;</span></span><br><span class="line">    __hashtable_node *next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFen</span>, <span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">    node *cur;</span><br><span class="line">    hashtable *ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面代码演示<code>hashtable</code>的使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hashtable&lt;pair&lt;<span class="keyword">const</span> <span class="built_in">string</span>, <span class="keyword">int</span>&gt;, </span><br><span class="line">		  <span class="built_in">string</span>, </span><br><span class="line">		  hash&lt;<span class="built_in">string</span>&gt;, </span><br><span class="line">		  select1st&lt;pair&lt;<span class="keyword">const</span> <span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;, </span><br><span class="line">		  equal_to&lt;<span class="built_in">string</span>&gt;, </span><br><span class="line">		  alloc&gt; siht(<span class="number">100</span>, hash&lt;<span class="built_in">string</span>&gt;(), equal_to&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>; 							<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.bucket_count() &lt;&lt; <span class="built_in">endl</span>;					<span class="comment">// 193</span></span><br><span class="line">siht.insert_unique(make_pair(<span class="built_in">string</span>(<span class="string">"jjhou"</span>), <span class="number">95</span>));</span><br><span class="line">siht.insert_unique(make_pair(<span class="built_in">string</span>(<span class="string">"sabrina"</span>), <span class="number">90</span>));</span><br><span class="line">siht.insert_unique(make_pair(<span class="built_in">string</span>(<span class="string">"mjchen"</span>), <span class="number">85</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;							<span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.bucket_count() &lt;&lt; <span class="built_in">endl</span>;					<span class="comment">// 193</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="string">"sabrina"</span>))-&gt;second &lt;&lt; <span class="built_in">endl</span>; 	<span class="comment">//90</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="string">"jjhou"</span>))-&gt;second &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//95</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; siht.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="string">"mjchen"</span>))-&gt;second &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//85</span></span><br></pre></td></tr></table></figure>
<h3 id="容器unordered-set、unordered-multiset、unordered-map和unordered-multimap"><a href="#容器unordered-set、unordered-multiset、unordered-map和unordered-multimap" class="headerlink" title="容器unordered_set、unordered_multiset、unordered_map和unordered_multimap"></a>容器<code>unordered_set</code>、<code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code></h3><p>C++11引入的容器<code>unordered_set</code>、<code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code>更名自gcc2.9的容器<code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>和<code>hash_multimap</code>,其底层封装了<code>hashtable</code>.用法与<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>类似.</p>
<h1 id="STL算法源码分析"><a href="#STL算法源码分析" class="headerlink" title="STL算法源码分析"></a>STL算法源码分析</h1><p>STL算法的一般形式如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">Algorithm(Iterator itr1, Iterator itr2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Cmp&gt;</span><br><span class="line">Algorithm(Iterator itr1, Iterator itr2, Cmp comp) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STL算法是看不到容器的,算法所需要的信息都是从<strong>迭代器</strong>取得的,因此迭代器内要存在与容器相关的信息,其中最重要的就是迭代器的5个关联类型.</p>
<h2 id="迭代器对算法的影响"><a href="#迭代器对算法的影响" class="headerlink" title="迭代器对算法的影响"></a>迭代器对算法的影响</h2><h3 id="迭代器的iterator-category类型"><a href="#迭代器的iterator-category类型" class="headerlink" title="迭代器的iterator_category类型"></a>迭代器的<code>iterator_category</code>类型</h3><p>迭代器的关联类型<code>iterator_category</code>表示迭代器类型,共5种,用类表示:<code>input_iterator_tag</code>、<code>output_iterator_tag</code>、<code>forward_iterator_tag</code>、<code>bidirectional_iterator_tag</code>和<code>random_acess_iterator_tag</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;:</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/g1RwMF" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RwMF.png" alt="g1RwMF.png"></a></p>
<p>之所以使用类而非枚举来表示迭代器类型,是出于一下两个考虑:</p>
<ul>
<li>使用类的继承可以表示不同迭代器类型的从属关系.</li>
<li>STL算法可以根据传入的迭代器类型调用不同版本的重载函数.</li>
</ul>
<p>下面的程序演示这两点.</p>
<p>下面程序用以演示不同容器的迭代器<code>iterator_category</code>值:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出迭代器类型,使用函数重载以应对不同类型的迭代器</span></span><br><span class="line"><span class="keyword">void</span> _display_category(random_access_iterator_tag) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"random_access_iterator"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> _display_category(bidirectional_iterator_tag) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bidirectional_iterator"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> _display_category(forward_iterator_tag) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"forward_iterator"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> _display_category(output_iterator_tag) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"output_iterator"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> _display_category(input_iterator_tag) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"input_iterator"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_category</span><span class="params">(I itr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::iterator_category cagy;</span><br><span class="line">    _display_category(cagy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出不同容器的迭代器类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_iterator_category</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    display_category(<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt;::iterator());				<span class="comment">// random_access_iterator</span></span><br><span class="line">    display_category(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator());					<span class="comment">// random_access_iterator</span></span><br><span class="line">    display_category(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator());					<span class="comment">// bidirectional_iterator</span></span><br><span class="line">    display_category(forward_list&lt;<span class="keyword">int</span>&gt;::iterator());			<span class="comment">// forward_iterator</span></span><br><span class="line">    display_category(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator());					<span class="comment">// random_access_iterator</span></span><br><span class="line"></span><br><span class="line">    display_category(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator());						<span class="comment">// bidirectional_iterator</span></span><br><span class="line">    display_category(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator());				<span class="comment">// bidirectional_iterator</span></span><br><span class="line">    display_category(<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator());				<span class="comment">// bidirectional_iterator</span></span><br><span class="line">    display_category(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator());			<span class="comment">// bidirectional_iterator</span></span><br><span class="line">    display_category(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator());			<span class="comment">// forward_iterator</span></span><br><span class="line">    display_category(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator());		<span class="comment">// forward_iterator</span></span><br><span class="line">    display_category(<span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator());		<span class="comment">// forward_iterator</span></span><br><span class="line">    display_category(<span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator());	<span class="comment">// forward_iterator</span></span><br><span class="line"></span><br><span class="line">    display_category(istream_iterator&lt;<span class="keyword">int</span>&gt;());					<span class="comment">// input_iterator</span></span><br><span class="line">    display_category(ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">""</span>));			<span class="comment">// output_iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/g1RBqJ" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RBqJ.png" alt="g1RBqJ.png"></a></p>
<p>容器<code>array</code>、<code>vector</code>、<code>deque</code>对使用者来说是连续空间,是<strong>可以跳跃</strong>的,其迭代器是<code>random_access_iterator</code>类型.</p>
<p>容器<code>list</code>是双向链表,容器<code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code>本身是有序的,他们的迭代器都可以双向移动,因此是<code>bidirectional_iterator</code>类型.</p>
<p>容器<code>forward_list</code>是单向链表,容器<code>unordered_set</code>、<code>unordered_map</code>、<code>unordered_multiset</code>、<code>unordered_map</code>哈希表中的每个桶都是单向链表.因此其迭代器只能单向移动,因此是<code>forward_iterator</code>类型.</p>
<p>迭代器<code>istream_iterator</code>和<code>ostream_iterator</code>本质上是迭代器,后文会提到这两个类的源码.</p>
<h3 id="iterator-traits和type-traits对算法的影响"><a href="#iterator-traits和type-traits对算法的影响" class="headerlink" title="iterator_traits和type_traits对算法的影响"></a><code>iterator_traits</code>和<code>type_traits</code>对算法的影响</h3><p>STL种的大部分算法都根据传入的迭代器类型以及其他信息调用不同的重载函数,针对特定的数据结构执行特定的优化</p>
<ul>
<li>STL中的算法<code>distance</code>根据不同的<code>iterator_category</code>执行不同的重载函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:diffrence_type</span><br><span class="line">_distance(InputIterator first, InputIterator last, input_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::diffrence_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        ++first;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;RandomAccessIterator&gt;:</span>:difference_type</span><br><span class="line">_distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:<span class="function">difference_type <span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>STL中的算法<code>advance</code>根据不同的<code>iterator_category</code>执行不同的重载函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectionalIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (n++)--i,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class RandomAccessIterator, class Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(RandomAccessIterator &amp;i, Distance n, random_access_iterator_tag) &#123;</span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">    _advance(i, n, category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>STL中的算法<code>copy</code>根据不同的<code>iterator_category</code>和<code>type_traits</code>执行不同的重载函数</li>
</ul>
<p><a href="https://imgtu.com/i/g1RsaR" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RsaR.png" alt="g1RsaR.png"></a></p>
<p>STL算法都是模板函数,无法对传入的<code>iterator_category</code>类型做出限定,但源码中的模板参数名还是对接收的<code>iterator_category</code>做出了一定的暗示.例如<code>sort</code>算法的模板参数类型名设为<code>RandomAccessIterator</code>,暗示了该算法只能接收<code>random_access_iterator_tag</code>类型的迭代器.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>C语言本身提供了一些算法,如<code>qsort</code>,不属于STL算法.STL算法应该满足下面的形式:模板函数,接收参数是迭代器和某些标准.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">Algorithm(Iterator itr1, Iterator itr2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Cmp&gt;</span><br><span class="line">Algorithm(Iterator itr1, Iterator itr2, Cmp comp) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法accumulate"><a href="#算法accumulate" class="headerlink" title="算法accumulate"></a>算法<code>accumulate</code></h3><p>算法<code>accumulate</code>的默认运算是<code>+</code>,但是重载版本允许自定义运算,支持所有容器,源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = init + *first;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>, <span class="title">BinaryOperation</span> <span class="title">binary_op</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = binary_op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面程序演示其使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::minus</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;      // std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + <span class="number">2</span> * y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + <span class="number">3</span> * y; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> init = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulate(nums, nums + <span class="number">3</span>, init);  				<span class="comment">// 使用默认运算`+`,输出160</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulate(nums, nums + <span class="number">3</span>, init, minus&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 使用仿函数指定运算`-`, 输出40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulate(nums, nums + <span class="number">3</span>, init, myfunc);    	<span class="comment">// 使用自定义函数指定运算, 输出220</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulate(nums, nums + <span class="number">3</span>, init, myobj);    	<span class="comment">// 使用四定义仿函数,输出280</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法for-each"><a href="#算法for-each" class="headerlink" title="算法for_each"></a>算法<code>for_each</code></h3><p>算法<code>for_each</code>支持所有容器,源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Function</span> <span class="title">for_each</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">Function</span> <span class="title">f</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        f(*first);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11中引入了新的range-based for语句,形式如下:</p>
<p><a href="https://imgtu.com/i/g1RyI1" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RyI1.png" alt="g1RyI1.png"></a></p>
<p>下面程序演示其使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), myfunc);	<span class="comment">// 使用自定义函数,输出10 20 30</span></span><br><span class="line">    for_each(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), myobj);	<span class="comment">// 使用自定义仿函数,输出10 20 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11引入的range-based for语法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : myvec)</span><br><span class="line">        elem += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : myvec)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; elem;    	<span class="comment">// 输出15 25 35</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法replace、replace-if、replace-copy"><a href="#算法replace、replace-if、replace-copy" class="headerlink" title="算法replace、replace_if、replace_copy"></a>算法<code>replace</code>、<code>replace_if</code>、<code>replace_copy</code></h3><ul>
<li><p>算法<code>replace</code>将范围内所有等于<code>old_value</code>的元素都用<code>new_value</code>取代.</p>
</li>
<li><p>算法<code>replace_if</code>将范围内所有满足<code>pred()</code>为<code>true</code>的元素都用<code>new_value</code>取代.</p>
</li>
<li><p>算法<code>replace_copy</code>将范围内所有等于<code>old_value</code>的元素都以<code>new_value</code>放入新区间,不等于<code>old_value</code>的元素直接放入新区间.</p>
</li>
</ul>
<p>它们支持所有容器,源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">old_value</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">new_value</span>) &#123;</span></span><br><span class="line">    <span class="comment">// 将范围内所有等于old_value的元素都用new_value取代</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (*first == old_value)</span><br><span class="line">            *first = new_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace_if</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">Predicate</span> <span class="title">pred</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">new_value</span>) &#123;</span></span><br><span class="line">	<span class="comment">// 将范围内所有满足pred()为true的元素都用new_value取代</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (pred(*first))</span><br><span class="line">            *first = new_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">replace_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">old_value</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">new_value</span>) &#123;</span></span><br><span class="line">	<span class="comment">// 将范围内所有等于old_value的元素都以new_value放入新区间,不等于old_value的元素直接放入新区间.</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first, ++result)</span><br><span class="line">        *result = (*first == old_value ? new_value : *first);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法count、count-if"><a href="#算法count、count-if" class="headerlink" title="算法count、count_if"></a>算法<code>count</code>、<code>count_if</code></h3><ul>
<li><p>算法<code>count</code>计算范围内等于<code>value</code>的元素个数.</p>
</li>
<li><p>算法<code>count_if</code>计算范围内所有满足<code>pred()</code>为<code>true</code>的元素个数.</p>
</li>
</ul>
<p>它们支持所有容器,但关联型容器(<code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code>、<code>unordered_set</code>、<code>unordered_map</code>、<code>unordered_multiset</code>和<code>unordered_map</code>)含有更高效的<code>count</code>方法,不应使用STL中的<code>count</code>函数.源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type </span><br><span class="line">count(InputIterator first, InputIterator last, <span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">    <span class="comment">// 计算范围内等于value的元素个数</span></span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) /</span><br><span class="line">        <span class="keyword">if</span> (*first == value)</span><br><span class="line">            ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">count_if(InputIterator first, InputIterator last, Predicate pred) &#123;</span><br><span class="line">    <span class="comment">// 计算范围内所有满足pred()为true的元素个数</span></span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (pred(*first))</span><br><span class="line">            ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法find、find-if"><a href="#算法find、find-if" class="headerlink" title="算法find、find_if"></a>算法<code>find</code>、<code>find_if</code></h3><ul>
<li><p>算法<code>find</code>查找范围内第一个等于<code>value</code>的元素.</p>
</li>
<li><p>算法<code>find_if</code>查找范围内第一个满足<code>pred()</code>为<code>true</code>的元素.</p>
</li>
</ul>
<p>它们支持所有容器,但关联型容器(<code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code>、<code>unordered_set</code>、<code>unordered_map</code>、<code>unordered_multiset</code>和<code>unordered_map</code>)含有更高效的<code>find</code>方法,不应使用STL中的<code>find</code>函数.源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last &amp;&amp; *first != value)</span><br><span class="line">        ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find_if</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">Predicate</span> <span class="title">pred</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last &amp;&amp; !pred(*first))</span><br><span class="line">        ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法sort"><a href="#算法sort" class="headerlink" title="算法sort"></a>算法<code>sort</code></h3><p>算法<code>sort</code>暗示参数为<code>random_access_iterator_tag</code>类型迭代器,因此该算法只支持容器<code>array</code>、<code>vector</code>和<code>deque</code>.</p>
<p>容器<code>list</code>和<code>forward_list</code>含有<code>sort</code>方法.</p>
<p>容器<code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code>本身是有序的,容器<code>unordered_set</code>、<code>unordered_map</code>、<code>unordered_multiset</code>和<code>unordered_map</code>本身是无序的,不需要排序.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面程序演示其使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i &lt; j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i &lt; j); &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myvec</span><span class="params">(myints, myints + <span class="number">8</span>)</span></span>;          <span class="comment">// myvec内元素: 32 71 12 45 26 80 53 33</span></span><br><span class="line"></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">begin</span>() + <span class="number">4</span>);         <span class="comment">// 使用默认`&lt;`运算定义顺序,myvec内元素: (12 32 45 71)26 80 53 33</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>() + <span class="number">4</span>, myvec.<span class="built_in">end</span>(), myfunc); 	<span class="comment">// 使用自定义函数定义顺序,myvec内元素: 12 32 45 71(26 33 53 80)</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), myobj);     	<span class="comment">// 使用自定义仿函数定义顺序,myvec内元素: (12 26 32 33 45 53 71 80)</span></span><br><span class="line">    sort(myvec.rbegin(), myvec.rend());				<span class="comment">// 使用反向迭代器逆向排序,myvec内元素: 80 71 53 45 33 32 26 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<code>rbegin</code>和<code>rend</code>是迭代器适配器,生成一个逆向增长的迭代器,后文会提到这两个类的源码.</p>
<p><a href="https://imgtu.com/i/g1RcPx" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RcPx.png" alt="g1RcPx.png"></a></p>
<h3 id="算法binary-search"><a href="#算法binary-search" class="headerlink" title="算法binary_search"></a>算法<code>binary_search</code></h3><p>算法<code>binary_search</code>从排好序的区间内查找元素<code>value</code>,支持所有可排序的容器.</p>
<p>算法<code>binary_search</code>内部调用了算法<code>lower_bound</code>,使用二分查找方式查询元素.</p>
<p>算法<code>lower_bound</code>和<code>upper_bound</code>分别返回对应元素的第一个和最后一个<strong>可插入位置</strong>.</p>
<p><a href="https://imgtu.com/i/g1R2RK" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1R2RK.png" alt="g1R2RK.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">val</span>) &#123;</span></span><br><span class="line">    first = <span class="built_in">std</span>::lower_bound(first, last, val);		<span class="comment">// 内部调用lower_bound</span></span><br><span class="line">    <span class="keyword">return</span> (first != last &amp;&amp; !(val &lt; *first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">lower_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">val</span>) &#123;</span></span><br><span class="line">    ForwardIterator it;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator&gt;::difference_type count, <span class="built_in">step</span>;</span><br><span class="line">    count = distance(first, last);</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        it = first;</span><br><span class="line">        <span class="built_in">step</span> = count / <span class="number">2</span>;</span><br><span class="line">        advance(it, <span class="built_in">step</span>);</span><br><span class="line">        <span class="keyword">if</span> (*it &lt; val) &#123; <span class="comment">// or: if (comp(*it,val)) for version (2)</span></span><br><span class="line">            first = ++it;</span><br><span class="line">            count -= <span class="built_in">step</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            count = <span class="built_in">step</span>;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/g1RRxO" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RRxO.png" alt="g1RRxO.png"></a></p>
<h1 id="STL仿函数源码分析"><a href="#STL仿函数源码分析" class="headerlink" title="STL仿函数源码分析"></a>STL仿函数源码分析</h1><p>仿函数是一类重载了<code>()</code>运算符的类,其对象可当作函数来使用,常被用做STL算法的参数.</p>
<p>STL的所有仿函数都必须继承自基类<code>unary_function</code>或<code>binary_function</code>,这两个基类定义了一系列关联类型,这些关联类型可被STL适配器使用.为了扩展性,我们自己写的仿函数也应当继承自这两个基类之一.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;			<span class="comment">// 关联类型1</span></span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;			<span class="comment">// 关联类型2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Argl</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Argl first_argument_type;	<span class="comment">// 关联类型1</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;	<span class="comment">// 关联类型2</span></span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;			<span class="comment">// 关联类型3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前文程序中用到的几个仿函数的源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算术运算类仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑运算类仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &amp;&amp; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对关系类仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前文程序中我们自定义的仿函数并没有继承自基类<code>unary_function</code>或<code>binary_function</code>,这样虽然能够运行,但是不好,因为没有继承自基类的仿函数无法与STL其他组件(尤其是<strong>函数适配器</strong>)结合起来.</p>
<h1 id="STL适配器源码分析"><a href="#STL适配器源码分析" class="headerlink" title="STL适配器源码分析"></a>STL适配器源码分析</h1><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>STL中:</p>
<ul>
<li>容器<code>stack</code>和<code>queue</code>是容器<code>deque</code>的适配器.</li>
<li>容器<code>set</code>、<code>map</code>、<code>multiset</code>和<code>multimap</code>是容器<code>rb_tree</code>的适配器.</li>
<li>容器<code>unordered_set</code>、<code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code>是容器<code>hashtable</code>的适配器.</li>
</ul>
<p>上述源码在前文中均已分析过.</p>
<h2 id="仿函数适配器"><a href="#仿函数适配器" class="headerlink" title="仿函数适配器"></a>仿函数适配器</h2><h3 id="仿函数适配器binder2nd及其辅助函数bind2nd"><a href="#仿函数适配器binder2nd及其辅助函数bind2nd" class="headerlink" title="仿函数适配器binder2nd及其辅助函数bind2nd"></a>仿函数适配器<code>binder2nd</code>及其辅助函数<code>bind2nd</code></h3><p>仿函数适配器<code>binder2nd</code>可以绑定二元仿函数的第二参数,生成新的仿函数.其源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放函数适配器binder2nd也是仿函数类,因此继承自仿函数基类unary_function</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">binder2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument type,</span><br><span class="line">        								<span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 内部成员,分别记录运算和第二实参</span></span><br><span class="line">    Operation op;	</span><br><span class="line">    <span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数,将运算和第二实参记录下来</span></span><br><span class="line">    binder2nd(<span class="keyword">const</span> Operation &amp;x, <span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type &amp;y)</span><br><span class="line">            : op(x), value(y) &#123;&#125; 	</span><br><span class="line">	<span class="comment">// 重载()运算符,传入第二参数</span></span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type &amp;x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> op(x, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>binder2nd</code>源码中,调用了<code>Operation</code>类的<code>first_argument</code>、<code>second_argument_type</code>和<code>result_type</code>,这些字段都是从STL仿函数基类<code>binary_function</code>继承得到的.因此我们自己写的仿函数也要继承自基类<code>binary_function</code>,才能使用适配器<code>binder2nd</code>进行增强.</p>
<p><code>binder2nd</code>适配器增强得到的仍然是一个仿函数,因此也要继承基类<code>unary_function</code>,以便被其它适配器增强.</p>
<p>使用类模板时必须指定模板参数的取值,因此将<code>binder2nd</code>封装进函数<code>bind2nd</code>中,使用函数模板的参数推导功能,简化代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">binder2nd</span>&lt;Operation&gt; <span class="title">bind2nd</span>(<span class="title">const</span> <span class="title">Operation</span> &amp;<span class="title">op</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line">    <span class="comment">// 传给bind2nd函数的第二参数必须能够转为Operation的第二参数类型,否则报错</span></span><br><span class="line">    <span class="keyword">return</span> binder2nd&lt;Operation&gt;(op, arg2_type(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以像前文例子中那样使用<code>bind2nd</code>了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; count_if(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span> (), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>));</span><br></pre></td></tr></table></figure>
<h3 id="仿函数适配器unary-negate及其辅助函数not1"><a href="#仿函数适配器unary-negate及其辅助函数not1" class="headerlink" title="仿函数适配器unary_negate及其辅助函数not1"></a>仿函数适配器<code>unary_negate</code>及其辅助函数<code>not1</code></h3><p>仿函数适配器<code>unary_negate</code>将仿函数的结果取反,生成新的仿函数.其源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仿函数适配器unary_negate也是仿函数类,因此继承自仿函数基类unary_function</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unary_negate</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 内部成员,记录被取反的仿函数</span></span><br><span class="line">    Predicate pred;		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数使用explicit修饰,避免隐式类型转换 </span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="keyword">const</span> Predicate &amp;x)</span> : <span class="title">pred</span><span class="params">(x)</span> </span>&#123;&#125;		</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 重载()运算符,将函数结果取反</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::argument_type &amp;x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !pred(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">unary_negate</span>&lt;Predicate&gt; <span class="title">not1</span>(<span class="title">const</span> <span class="title">Predicate</span> &amp;<span class="title">pred</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以像前文例子中那样使用<code>not1</code>了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; count_if(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span> (), not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>
<h3 id="仿函数适配器bind"><a href="#仿函数适配器bind" class="headerlink" title="仿函数适配器bind"></a>仿函数适配器<code>bind</code></h3><p>在库文件<code>include/c++/backward/backward_warning.h</code>中列出了一系列C++11中废弃了的STL类及其替代类.</p>
<table>
<thead>
<tr>
<th style="text-align:center">被废弃的类及其头文件位置</th>
<th style="text-align:center">替代类及其头文件位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;strstream&gt;</code>, strstreambuf</td>
<td style="text-align:center"><code>&lt;sstream&gt;</code>, basic_stringbuf</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;strstream&gt;</code>, istrstream</td>
<td style="text-align:center"><code>&lt;sstream&gt;</code>, basic_istringstream</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;strstream&gt;</code>, ostrstream</td>
<td style="text-align:center"><code>&lt;sstream&gt;</code>, basic_ostringstream</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;strstream&gt;</code>, strstream</td>
<td style="text-align:center"><code>&lt;sstream&gt;</code>, basic_stringstream</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;ext/hash_set&gt;</code>, hash_set</td>
<td style="text-align:center"><code>&lt;unordered_set&gt;</code>, unordered_set</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;ext/hash_set&gt;</code>, hash_multiset</td>
<td style="text-align:center"><code>&lt;unordered_set&gt;</code>, unordered_multiset</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;ext/hash_map&gt;</code>, hash_map</td>
<td style="text-align:center"><code>&lt;unordered_map&gt;</code>, unordered_map</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;ext/hash_map&gt;</code>, hash_multimap</td>
<td style="text-align:center"><code>&lt;unordered_map&gt;</code>, unordered_multimap</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;functional&gt;</code>, binder1st</td>
<td style="text-align:center"><code>&lt;functional&gt;</code>, bind</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;functional&gt;</code>, binder2nd</td>
<td style="text-align:center"><code>&lt;functional&gt;</code>, bind</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;functional&gt;</code>, bind1st</td>
<td style="text-align:center"><code>&lt;functional&gt;</code>, bind</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;functional&gt;</code>, bind2nd</td>
<td style="text-align:center"><code>&lt;functional&gt;</code>, bind</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;memory&gt;</code>, auto_ptr</td>
<td style="text-align:center"><code>&lt;memory&gt;</code>, unique_ptr</td>
</tr>
</tbody>
</table>
<p>其中用于绑定函数参数的类<code>binder1st</code>和<code>binder2nd</code>及其辅助函数<code>bind1st</code>和<code>bind2nd</code>都被替换为功能更强大的<code>bind</code>.</p>
<p>函数<code>bind</code>要和命名空间<code>std::placeholders</code>中的占位符<code>_1</code>、<code>_2</code>、<code>_3</code>…等占位符配合使用.<code>bind</code>函数可以绑定:</p>
<ul>
<li>函数和函数对象.</li>
<li>成员函数(绑定成员函数时占位符<code>_1</code>必须是该类对象的地址).</li>
<li>成员变量(绑定成员变量时占位符<code>_1</code>必须是该类对象的地址).</li>
</ul>
<p>下面程序演示其使用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPair</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">// 引入占位符_1, _2, _3,...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将10和2绑定到函数的第一参数和第二参数上</span></span><br><span class="line">    <span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind(my_divide, <span class="number">10</span>, <span class="number">2</span>);               <span class="comment">// returns 10/2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将2绑定到函数的第一参数上</span></span><br><span class="line">    <span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind(my_divide, _1, <span class="number">2</span>);               <span class="comment">// returns x/2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数的第一参数和第二参数绑定到第二参数和第一参数上</span></span><br><span class="line">    <span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind(my_divide, _2, _1);            <span class="comment">// returns y/x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将int绑定到函数的返回值上</span></span><br><span class="line">    <span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt;(my_divide, _1, _2);     <span class="comment">// returns int(x/y)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    MyPair ten_two&#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象ten_two绑定到函数的第一参数上</span></span><br><span class="line">    <span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind(&amp;MyPair::multiply, _1); <span class="comment">// returns x.multiply()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将对象ten_two绑定到函数的成员变量上</span></span><br><span class="line">    <span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind(&amp;MyPair::a, ten_two); <span class="comment">// returns ten_two.a</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>;                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h2><h3 id="逆向迭代器reverse-iterator"><a href="#逆向迭代器reverse-iterator" class="headerlink" title="逆向迭代器reverse_iterator"></a>逆向迭代器<code>reverse_iterator</code></h3><p>容器的<code>rbegin()</code>和<code>rend()</code>方法返回逆向迭代器<code>reverse_iterator</code>,逆向迭代器的方向与原始迭代器相反.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">container</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> reverse_iterator(<span class="built_in">end</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverse_iterator(<span class="built_in">begin</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向迭代器适配器<code>reverse_iterator</code>与正常迭代器的方向正好相反:逆向迭代器的尾(头)就是正向迭代器的头(尾);逆向迭代器的加(减)运算就是正向迭代器的减(加)运算.因此逆向迭代器取值时取得是迭代器前面一格元素的值.</p>
<p><a href="https://imgtu.com/i/g1RgG6" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RgG6.png" alt="g1RgG6.png"></a></p>
<p><code>reverse_iterator</code>源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">reverse_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Iterator current;			<span class="comment">// 对应的正向迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 逆向迭代器的5种关联类型与正向迭代器相同</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::itrator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type value_type;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">typedef</span> Iterator iterator_type;				<span class="comment">// 正向迭代器类型</span></span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self;	<span class="comment">// 逆向迭代器类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type x)</span> : <span class="title">current</span><span class="params">(x)</span> </span>&#123;&#125;</span><br><span class="line">    reverse_iterator(<span class="keyword">const</span> self &amp;x) : current(x.current) &#123;&#125;</span><br><span class="line">    <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current; &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆向迭代器取值: 就是将迭代器视为正向迭代器,退一格再取值</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        Iterator tmp = current;</span><br><span class="line">        <span class="keyword">return</span> *--tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆向迭代器的加运算对应正向迭代器的减运算</span></span><br><span class="line">    self &amp;<span class="keyword">operator</span>++() &#123; --current;<span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    self &amp;<span class="keyword">operator</span>--() &#123; ++current;<span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> self(current - n); &#125;</span><br><span class="line">    self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> self(current + n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="用于插入的迭代器insert-iterator及其辅助函数inserter"><a href="#用于插入的迭代器insert-iterator及其辅助函数inserter" class="headerlink" title="用于插入的迭代器insert_iterator及其辅助函数inserter"></a>用于插入的迭代器<code>insert_iterator</code>及其辅助函数<code>inserter</code></h3><p>迭代器适配器<code>insert_iterator</code>生成用于原地插入运算的迭代器,使用<code>insert_iterator</code>迭代器插入元素时,就将原有位置的元素向后推.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; foo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; bar = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = foo.<span class="built_in">begin</span>();</span><br><span class="line">advance(it, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">copy(bar.<span class="built_in">begin</span>(), bar.<span class="built_in">end</span>(), inserter(foo, it));</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/g1RfMD" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RfMD.png" alt="g1RfMD.png"></a></p>
<p><code>insert_iterator</code>通过重载运算符<code>=</code>、<code>*</code>和<code>++</code>实现上述功能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类insert_iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">insert_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 内部成员,记录底层容器和迭代器</span></span><br><span class="line">    Container *container; </span><br><span class="line">    <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义5个关联类型</span></span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_category; 	</span><br><span class="line">    </span><br><span class="line">    insert_iterator(Container &amp;x, <span class="keyword">typename</span> Container::iterator i)</span><br><span class="line">            : container(&amp;x), iter(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符=</span></span><br><span class="line">    insert_iterator&lt;Container&gt; &amp;</span><br><span class="line">	<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">typename</span> Container::value_type &amp;value) &#123;</span><br><span class="line">        iter = container-&gt;insert(iter, value); 		<span class="comment">// 调用底层容器的insert</span></span><br><span class="line">        ++iter; 									<span class="comment">// 令insert_iterator永远随其target同步移动</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 重载运算符*和++: 不做任何动作</span></span><br><span class="line">    insert_iterator&lt;Container&gt; &amp;<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    insert_iterator&lt;Container&gt; &amp;<span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    insert_iterator&lt;Container&gt; &amp;<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数inserter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>, <span class="title">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">insert_iterator</span>&lt;Container&gt; <span class="title">inserter</span>(<span class="title">Container</span> &amp;<span class="title">x</span>, <span class="title">Iterator</span> <span class="title">i</span>) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line">    <span class="keyword">return</span> insert_iterator&lt;Container&gt;(x, iter(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出流迭代器ostream-iterator"><a href="#输出流迭代器ostream-iterator" class="headerlink" title="输出流迭代器ostream_iterator"></a>输出流迭代器<code>ostream_iterator</code></h3><p>输出流迭代器<code>ostream_iterator</code>常用于封装<code>std::cout</code>.下面程序将容器中元素输出到<code>std::cout</code>中.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_it</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">","</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::copy(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), out_it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ostream_iterator</code>重载了运算符<code>=</code>,<code>*</code>和<code>++</code>,其源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">charT</span>=<span class="title">char</span>, <span class="title">class</span> <span class="title">traits</span> =<span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ostream_iterator</span> :</span> <span class="keyword">public</span> iterator&lt;output_iterator_tag, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    basic_ostream&lt;charT, traits&gt; *out_stream;</span><br><span class="line">    <span class="keyword">const</span> charT *delim;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> charT char_type,</span><br><span class="line">    <span class="keyword">typedef</span> traits traits_type,</span><br><span class="line">    <span class="keyword">typedef</span> basic_ostream&lt;charT, traits&gt; ostream_type;</span><br><span class="line"></span><br><span class="line">    ostream_iterator(ostream_type &amp;s) : out_stream(&amp;s), delim(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ostream_iterator(ostream_type &amp;s, <span class="keyword">const</span> charT *delimiter)</span><br><span class="line">            : out_stream(&amp;s), delim(delimiter) &#123;&#125;</span><br><span class="line">    ostream_iterator(<span class="keyword">const</span> ostream_iterator&lt;T, charT, traits&gt; &amp;x)</span><br><span class="line">            : out_stream(x.out_stream), delim(x.delim) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 重载运算符=: 执行输出</span></span><br><span class="line">    ostream_iterator&lt;T, charT, traits&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        *out_stream &lt;&lt; value;</span><br><span class="line">        <span class="keyword">if</span> (delim != <span class="number">0</span>) </span><br><span class="line">            *out_stream &lt;&lt; delim;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符*和++: 不做任何动作</span></span><br><span class="line">    ostream_iterator&lt;T, charT, traits&gt; &amp;<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    ostream_iterator&lt;T, charT, traits&gt; &amp;<span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    ostream_iterator&lt;T, charT, traits&gt; &amp;<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输入流迭代器istream-iterator"><a href="#输入流迭代器istream-iterator" class="headerlink" title="输入流迭代器istream_iterator"></a>输入流迭代器<code>istream_iterator</code></h3><p>输入流迭代器<code>istream_iterator</code>用于封装<code>std::cin</code>,下面程序从<code>std::in</code>中读取数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::istream_iterator&lt;<span class="keyword">double</span>&gt; eos; 				<span class="comment">// 标志迭代器,通过与该迭代其比较以判断输入流是否终止</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream_iterator&lt;<span class="keyword">double</span>&gt; <span class="title">iit</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">cin</span>)</span></span>; 	<span class="comment">// 封装std::cin的输入流迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> value;</span><br><span class="line"><span class="keyword">if</span> (iit != eos) </span><br><span class="line">    value = *iit;		<span class="comment">// 从输入流读取数据到变量value中,相当于: std::cin &gt;&gt; cvalue</span></span><br></pre></td></tr></table></figure>
<p><code>istream_iterator</code>重载了运算符<code>=</code>,<code>*</code>和<code>++</code>,其源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">charT</span>=<span class="title">char</span>, <span class="title">class</span> <span class="title">traits</span>=<span class="title">char_traits</span>&lt;charT&gt;, <span class="title">class</span> <span class="title">Distance</span>=<span class="title">ptrdiff_t</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">istream_iterator</span> :</span></span><br><span class="line">        <span class="keyword">public</span> iterator&lt;input_iterator_tag, T, Distance, <span class="keyword">const</span> T *, <span class="keyword">const</span> T &amp;&gt; &#123;</span><br><span class="line">    basic_istream&lt;charT, traits&gt; *in_stream;	<span class="comment">// 输入流</span></span><br><span class="line">    T value;									<span class="comment">// 上一次读入的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> charT char_type;</span><br><span class="line">    <span class="keyword">typedef</span> traits traits_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_istream&lt;charT, traits&gt; istream_type;</span><br><span class="line"></span><br><span class="line">    istream_iterator() : in_stream(<span class="number">0</span>) &#123;&#125;							<span class="comment">// 空迭代器,表示输入流终止</span></span><br><span class="line">    istream_iterator(istream_type &amp;s) : in_stream(&amp;s) &#123; ++*<span class="keyword">this</span>; &#125;	<span class="comment">// 创建好迭代器后马上读入一个值 </span></span><br><span class="line">    <span class="function">istream <span class="title">iterator</span><span class="params">(<span class="keyword">const</span> istream_iterator&lt;T, charT, traits, Distance&gt; &amp;x)</span></span></span><br><span class="line">            : in_stream(x.in_stream), value(x.value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符++</span></span><br><span class="line">    istream_iterator&lt;T, charT, traits, Distance&gt; &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (in_stream &amp;&amp; !(*in_stream &gt;&gt; value)) </span><br><span class="line">            in_stream = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	istream_iterator&lt;T, charT, traits, Distance&gt; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        istream_iterator&lt;T, charT, traits, Distance&gt; tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 重载运算符*和-&gt;</span></span><br><span class="line">    <span class="keyword">const</span> T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">const</span> T *<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面程序使用输入流迭代器<code>istream_iterator</code>从<code>std::cin</code>中读取数据到容器中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; iit(cin), eos;</span><br><span class="line">copy(iit, eos, inserter(c, c.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/g1Rhse" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1Rhse.png" alt="g1Rhse.png"></a></p>
<h1 id="其它标准库相关的话题"><a href="#其它标准库相关的话题" class="headerlink" title="其它标准库相关的话题"></a>其它标准库相关的话题</h1><h2 id="容器tuple"><a href="#容器tuple" class="headerlink" title="容器tuple"></a>容器<code>tuple</code></h2><h3 id="使用tuple"><a href="#使用tuple" class="headerlink" title="使用tuple"></a>使用<code>tuple</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建tuple</span></span><br><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; &gt; t;</span><br><span class="line">tuple&lt;int, float, string&gt; t1(41, 6.3, "nico");	// 指定初值</span><br><span class="line"><span class="keyword">auto</span> t2 = make_tuple(<span class="number">22</span>, <span class="number">44</span>, <span class="string">"stacy"</span>);			<span class="comment">// 使用make_tuple函数创建tuple</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get&lt;&gt;()函数获取tuple内的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"t1:"</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">"&lt;&lt; get&lt;1&gt;(t1)&lt;&lt;"</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t1) = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t2);		<span class="comment">// 获取的元素是左值,可以对其赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple可以直接进行比较</span></span><br><span class="line"><span class="keyword">if</span> (t1 &lt; t2) &#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 &lt; t2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 &gt;= t2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接拷贝构造</span></span><br><span class="line">t1 = t2; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用tie函数将tuple的元素绑定到变量上</span></span><br><span class="line">tuple&lt;int, float, string&gt; t3(77, 1.1, "more light");</span><br><span class="line"><span class="keyword">int</span> i1, <span class="keyword">float</span> f1; <span class="built_in">string</span> s1;</span><br><span class="line">tie(i1, f1, s1) = t3; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断 tuple 类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(t3)</span> TupleType</span>;		<span class="comment">// 推断出 t3 的类型为 tuple&lt;int, float, string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 tuple_size 获取元素个数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; <span class="built_in">endl</span>; 		<span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 使用 tuple_element 获取元素类型</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>, TupleType&gt;::type fl = <span class="number">1.0</span>; 		<span class="comment">// float</span></span><br></pre></td></tr></table></figure>
<h3 id="tuple类源码分析"><a href="#tuple类源码分析" class="headerlink" title="tuple类源码分析"></a><code>tuple</code>类源码分析</h3><p>容器<code>tuple</code>的源码使用可变模板参数,递归调用不同模板参数的tuple构造函数,以处理任意多的元素类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 tuple类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化模板参数: 空参</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head, Tail...&gt; :</span></span><br><span class="line">        <span class="keyword">private</span> tuple&lt;Tail...&gt;        	<span class="comment">// tuple类继承自tuple类,父类比子类少了一个模板参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;	<span class="comment">// 父类类型  </span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;						<span class="comment">// 保存第一个元素的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tuple() &#123;&#125;</span><br><span class="line">    tuple(Head v, Tail... vtail)		<span class="comment">// 构造函数: 将第一个元素赋值给m_head,使用其他元素构建父类tuple</span></span><br><span class="line">		: m_head(v), inherited(vtail...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;		<span class="comment">// 返回第一个元素值</span></span><br><span class="line">    <span class="function">inherited &amp;<span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;	<span class="comment">// 返回剩余元素组成的tuple(将当前元素强制转换为父类类型)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/g1R4qH" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1R4qH.png" alt="g1R4qH.png"></a></p>
<p>调用<code>head</code>函数返回的是元素<code>m_head</code>的值.</p>
<p>调用<code>tail</code>函数返回父类成分的起点,通过强制转换将当前<code>tuple</code>转换为父类<code>tuple</code>,丢弃了元素<code>m_head</code>所占内存.</p>
<h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h2><p><strong>类型萃取</strong>机制(type traits)获取与类有关的信息,在C++11之前和C++11中分别由不同的实现方式.</p>
<h3 id="C-11之前的类型萃取机制-type-traits"><a href="#C-11之前的类型萃取机制-type-traits" class="headerlink" title="C++11之前的类型萃取机制:__type_traits"></a>C++11之前的类型萃取机制:<code>__type_traits</code></h3><p>在C++11之前,类型萃取机制是由<code>__type_traits</code>实现的.我们每创建一个类,就要以该类为模板参数特化一个<code>__type_traits</code>类.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;   <span class="comment">// 默认构造函数是否可忽略</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;      <span class="comment">// 拷贝构造函数是否可忽略</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;   <span class="comment">// 赋值函数是否可忽略</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;            <span class="comment">// 析构函数是否可忽略</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;                       <span class="comment">// 是否是POD(plain old data)类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;double&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span> <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span> <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>这种实现方式比较麻烦,因此C++11以一种新的方式引入<code>type traits</code>机制.</p>
<h3 id="C-11中的类型萃取机制-辅助类"><a href="#C-11中的类型萃取机制-辅助类" class="headerlink" title="C++11中的类型萃取机制:辅助类"></a>C++11中的类型萃取机制:辅助类</h3><p>C++11在头文件<code>type_traits</code>中引入了一系列辅助类,这些辅助类能根据传入的模板参数自动进行获取该类的基本信息,实现类型萃取,并不需要我们为自己创建的类手动编写类型萃取信息.</p>
<p>官方网站上列出了所有用于类型萃取的辅助函数:</p>
<p><a href="https://imgtu.com/i/g1RIZd" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/05/07/g1RIZd.png" alt="g1RIZd.png"></a></p>
<p>下面例子展示类型萃取机制的应用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is_ void\t"</span> &lt;&lt; is_void&lt;T&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is_ integral\t"</span> &lt;&lt; is_integral&lt;T&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is_ floating point\t"</span> &lt;&lt; is_floating_point&lt;T&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="类型萃取机制源码分析"><a href="#类型萃取机制源码分析" class="headerlink" title="类型萃取机制源码分析"></a>类型萃取机制源码分析</h3><p>头文件<code>type_traits</code>中定义了辅助类<code>remove_const</code>和<code>remove_volatile</code>用于除去类型中的<code>const</code>和<code>volatile</code>关键字.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove const</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;_Tp const&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove volatile</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span>&lt;_Tp volatile&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>is_void</code>类继承自<code>__is_void_helper</code>类,<code>__is_void_helper</code>类使用偏特化的形式判断传入的模板参数是否为<code>void</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span>&lt;void&gt;</span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> true_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> __is_void_helper&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt;::type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>is_integral</code>类继承自<code>__is_integral_helper</code>类,同样使用偏特化的方式判断传入的模板参数是否为整数类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_integral_helper</span> :</span> <span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">is_integral_helper</span>&lt;bool&gt; :</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">is_integral_helper</span>&lt;char&gt; :</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">is_integral_helper</span>&lt;signed char&gt; :</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">is_integral_helper</span>&lt;unsigned char&gt; :</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> __is_integral_helper&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt;::type &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>一些type traits辅助类(如<code>is_enum</code>、<code>is_union</code>和<code>is_class</code>等)是由编译器实现的,STL源码中找不到其实现函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is_enum</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_enum</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, __is_enum(_Tp)&gt;    <span class="comment">// __is_enum函数是由编译器实现的,STL源码中找不到其源码</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is_union</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_union</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, __is_union(_Tp)&gt;    <span class="comment">// __is_union函数是由编译器实现的,STL源码中找不到其源码</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is_class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_class</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, __is_class(_Tp)&gt;    <span class="comment">// __is_class函数是由编译器实现的,STL源码中找不到其源码</span></span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/STL/" rel="tag"># STL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/03/面经知识汇总/" rel="next" title="面经知识汇总*">
                <i class="fa fa-chevron-left"></i> 面经知识汇总*
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/09/面试汇总/" rel="prev" title="面试汇总*">
                面试汇总* <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://imgtu.com/i/gw3nYT" alt="Austin Deng">
            
              <p class="site-author-name" itemprop="name">Austin Deng</p>
              <p class="site-description motion-element" itemprop="description">凡心所向，素履以往；生如逆旅，一苇以航。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#STL各组件应用示例"><span class="nav-number">1.</span> <span class="nav-text">STL各组件应用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL六大组件"><span class="nav-number">1.1.</span> <span class="nav-text">STL六大组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">1.2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用array"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用vector"><span class="nav-number">1.2.2.</span> <span class="nav-text">使用vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用list"><span class="nav-number">1.2.3.</span> <span class="nav-text">使用list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用forward-list"><span class="nav-number">1.2.4.</span> <span class="nav-text">使用forward_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用deque"><span class="nav-number">1.2.5.</span> <span class="nav-text">使用deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用stack和queue"><span class="nav-number">1.2.6.</span> <span class="nav-text">使用stack和queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用multiset和multimap"><span class="nav-number">1.2.7.</span> <span class="nav-text">使用multiset和multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用unordered-multiset和unordered-multimap"><span class="nav-number">1.2.8.</span> <span class="nav-text">使用unordered_multiset和unordered_multimap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配器"><span class="nav-number">1.3.</span> <span class="nav-text">分配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL容器源码分析"><span class="nav-number">2.</span> <span class="nav-text">STL容器源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL设计模式-OOP和GP"><span class="nav-number">2.1.</span> <span class="nav-text">STL设计模式:OOP和GP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载与模板特化"><span class="nav-number">2.2.</span> <span class="nav-text">运算符重载与模板特化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配器-1"><span class="nav-number">2.3.</span> <span class="nav-text">分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器-1"><span class="nav-number">2.4.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#容器list"><span class="nav-number">2.4.1.</span> <span class="nav-text">容器list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器vector"><span class="nav-number">2.4.2.</span> <span class="nav-text">容器vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器array"><span class="nav-number">2.4.3.</span> <span class="nav-text">容器array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器deque"><span class="nav-number">2.4.4.</span> <span class="nav-text">容器deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器queue和stack"><span class="nav-number">2.4.5.</span> <span class="nav-text">容器queue和stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器rbtree"><span class="nav-number">2.4.6.</span> <span class="nav-text">容器rbtree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器set和multiset"><span class="nav-number">2.4.7.</span> <span class="nav-text">容器set和multiset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器map和multimap"><span class="nav-number">2.4.8.</span> <span class="nav-text">容器map和multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器hashtable"><span class="nav-number">2.4.9.</span> <span class="nav-text">容器hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器unordered-set、unordered-multiset、unordered-map和unordered-multimap"><span class="nav-number">2.4.10.</span> <span class="nav-text">容器unordered_set、unordered_multiset、unordered_map和unordered_multimap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL算法源码分析"><span class="nav-number">3.</span> <span class="nav-text">STL算法源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器对算法的影响"><span class="nav-number">3.1.</span> <span class="nav-text">迭代器对算法的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器的iterator-category类型"><span class="nav-number">3.1.1.</span> <span class="nav-text">迭代器的iterator_category类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iterator-traits和type-traits对算法的影响"><span class="nav-number">3.1.2.</span> <span class="nav-text">iterator_traits和type_traits对算法的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">3.2.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法accumulate"><span class="nav-number">3.2.1.</span> <span class="nav-text">算法accumulate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法for-each"><span class="nav-number">3.2.2.</span> <span class="nav-text">算法for_each</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法replace、replace-if、replace-copy"><span class="nav-number">3.2.3.</span> <span class="nav-text">算法replace、replace_if、replace_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法count、count-if"><span class="nav-number">3.2.4.</span> <span class="nav-text">算法count、count_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法find、find-if"><span class="nav-number">3.2.5.</span> <span class="nav-text">算法find、find_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法sort"><span class="nav-number">3.2.6.</span> <span class="nav-text">算法sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法binary-search"><span class="nav-number">3.2.7.</span> <span class="nav-text">算法binary_search</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL仿函数源码分析"><span class="nav-number">4.</span> <span class="nav-text">STL仿函数源码分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL适配器源码分析"><span class="nav-number">5.</span> <span class="nav-text">STL适配器源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器适配器"><span class="nav-number">5.1.</span> <span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#仿函数适配器"><span class="nav-number">5.2.</span> <span class="nav-text">仿函数适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#仿函数适配器binder2nd及其辅助函数bind2nd"><span class="nav-number">5.2.1.</span> <span class="nav-text">仿函数适配器binder2nd及其辅助函数bind2nd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#仿函数适配器unary-negate及其辅助函数not1"><span class="nav-number">5.2.2.</span> <span class="nav-text">仿函数适配器unary_negate及其辅助函数not1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#仿函数适配器bind"><span class="nav-number">5.2.3.</span> <span class="nav-text">仿函数适配器bind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器适配器"><span class="nav-number">5.3.</span> <span class="nav-text">迭代器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逆向迭代器reverse-iterator"><span class="nav-number">5.3.1.</span> <span class="nav-text">逆向迭代器reverse_iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用于插入的迭代器insert-iterator及其辅助函数inserter"><span class="nav-number">5.3.2.</span> <span class="nav-text">用于插入的迭代器insert_iterator及其辅助函数inserter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出流迭代器ostream-iterator"><span class="nav-number">5.3.3.</span> <span class="nav-text">输出流迭代器ostream_iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入流迭代器istream-iterator"><span class="nav-number">5.3.4.</span> <span class="nav-text">输入流迭代器istream_iterator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其它标准库相关的话题"><span class="nav-number">6.</span> <span class="nav-text">其它标准库相关的话题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器tuple"><span class="nav-number">6.1.</span> <span class="nav-text">容器tuple</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用tuple"><span class="nav-number">6.1.1.</span> <span class="nav-text">使用tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuple类源码分析"><span class="nav-number">6.1.2.</span> <span class="nav-text">tuple类源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-traits"><span class="nav-number">6.2.</span> <span class="nav-text">type traits</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11之前的类型萃取机制-type-traits"><span class="nav-number">6.2.1.</span> <span class="nav-text">C++11之前的类型萃取机制:__type_traits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11中的类型萃取机制-辅助类"><span class="nav-number">6.2.2.</span> <span class="nav-text">C++11中的类型萃取机制:辅助类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型萃取机制源码分析"><span class="nav-number">6.2.3.</span> <span class="nav-text">类型萃取机制源码分析</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Austin Deng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
