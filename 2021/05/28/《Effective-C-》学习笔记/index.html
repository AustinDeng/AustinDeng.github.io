<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习笔记,C++,">










<meta name="description" content="让自己习惯C++条款01： 视 C++ 为一个语言联邦C++ 包含了多种泛型编程：  过程形式 面向对象形式 函数形式 泛型形式 元编程形式  将C++视作一个由相关语言组成的联邦而非单一语言：  C。 区块、语句、预处理器、内置数据类型、数组、指针 没有模板、没有异常、没有重载   Object-Oriented C++。 类、封装、继承、多态、virtual函数(动态绑定)   Templat">
<meta name="keywords" content="学习笔记,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective C++》学习笔记">
<meta property="og:url" content="http://yoursite.com/2021/05/28/《Effective-C-》学习笔记/index.html">
<meta property="og:site_name" content="邓某的杂货铺">
<meta property="og:description" content="让自己习惯C++条款01： 视 C++ 为一个语言联邦C++ 包含了多种泛型编程：  过程形式 面向对象形式 函数形式 泛型形式 元编程形式  将C++视作一个由相关语言组成的联邦而非单一语言：  C。 区块、语句、预处理器、内置数据类型、数组、指针 没有模板、没有异常、没有重载   Object-Oriented C++。 类、封装、继承、多态、virtual函数(动态绑定)   Templat">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-05-31T03:38:00.190Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Effective C++》学习笔记">
<meta name="twitter:description" content="让自己习惯C++条款01： 视 C++ 为一个语言联邦C++ 包含了多种泛型编程：  过程形式 面向对象形式 函数形式 泛型形式 元编程形式  将C++视作一个由相关语言组成的联邦而非单一语言：  C。 区块、语句、预处理器、内置数据类型、数组、指针 没有模板、没有异常、没有重载   Object-Oriented C++。 类、封装、继承、多态、virtual函数(动态绑定)   Templat">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/28/《Effective-C-》学习笔记/">





  <title>《Effective C++》学习笔记 | 邓某的杂货铺</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">邓某的杂货铺</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">凡心所向，素履以往；生如逆旅，一苇以航。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/28/《Effective-C-》学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Austin Deng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/images.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邓某的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Effective C++》学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-28T18:53:13+08:00">
                2021-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：-视-C-为一个语言联邦"><a href="#条款01：-视-C-为一个语言联邦" class="headerlink" title="条款01： 视 C++ 为一个语言联邦"></a>条款01： 视 C++ 为一个语言联邦</h3><p>C++ 包含了多种泛型编程：</p>
<ul>
<li>过程形式</li>
<li>面向对象形式</li>
<li>函数形式</li>
<li>泛型形式</li>
<li>元编程形式</li>
</ul>
<p>将C++视作一个由相关语言组成的联邦而非单一语言：</p>
<ul>
<li>C。<ul>
<li>区块、语句、预处理器、内置数据类型、数组、指针</li>
<li>没有模板、没有异常、没有重载</li>
</ul>
</li>
<li>Object-Oriented C++。<ul>
<li>类、封装、继承、多态、virtual函数(动态绑定)</li>
</ul>
</li>
<li>Template C++：<ul>
<li>泛型编程</li>
<li>template metaprogramming(TMP 模板元编程)</li>
</ul>
</li>
<li>STL</li>
</ul>
<p>C++ 高效编程守则视状况而变化，取决于你使用C++哪一部分。</p>
<a id="more"></a>
<h3 id="条款02：-尽量以-const，enum，inline-替换-define"><a href="#条款02：-尽量以-const，enum，inline-替换-define" class="headerlink" title="条款02： 尽量以 const，enum，inline 替换 #define"></a>条款02： 尽量以 const，enum，inline 替换 #define</h3><p>将 <code>#define ASPECT_RATIO 1.653</code>替换为<code>const double AspectRatio = 1.653</code></p>
<p>定义一个常量的<code>char*-based</code>字符串<br>将<code>const char* const authorName = &quot;Scott Meyers&quot;;</code>替换为<code>const std::string authorName(&quot;Scott Meyers&quot;);</code></p>
<p>我们无法利用<code>#define</code>创建一个 <code>class</code>专属常量，因为<code>#define</code>并不重视作用域(scope)</p>
<h4 id="emum-hack"><a href="#emum-hack" class="headerlink" title="emum hack"></a>emum hack</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurn = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurn];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于编译器坚持必须在编译期间知道数组大小，可能导致编译器(错误地)不允许“static 整数型 class 常量”完成“in class 初值设定”</p>
<p>所以可以这么做<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurn = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurn];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enum hack 的行为某方面更像#define而不像const。<br>例如：取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址也不合法。</p>
<h3 id="使用-define实现宏-macros"><a href="#使用-define实现宏-macros" class="headerlink" title="使用#define实现宏(macros)"></a>使用<code>#define</code>实现宏(macros)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 a 和 b 的较大值调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p>会遇到这样的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);     <span class="comment">// a 被累加二次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);  <span class="comment">// a 被累加一次</span></span><br></pre></td></tr></table></figure>
<p>只要用 template inline 解决即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;    <span class="comment">// 由于不知道T是什么，所以采用 pass by reference-to-const</span></span><br><span class="line">    f(a &gt; b ? a: b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对于单纯常量，最好以 const 对象或 enums 替换 #define</li>
<li>对于形似函数的宏(macros),最好改用inline函数替换 #defines</li>
</ul>
<h3 id="条款03：-尽可能使用-const"><a href="#条款03：-尽可能使用-const" class="headerlink" title="条款03： 尽可能使用 const"></a>条款03： 尽可能使用 const</h3><p>面对指针，你可以指出指针自身、指针所指物，或者两者都（或都不）是const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;         </span><br><span class="line"><span class="keyword">char</span>* p = greeting;                <span class="comment">// non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;          <span class="comment">// non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;          <span class="comment">// const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;    <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>如果关键字 const 出现在星号左边，说明被指物是常量<br>如果关键字 const 出现在星号右边，说明指针自身是常量<br>如果关键字 const 出现在星号两边，说明被指物和指针两者都是常量</p>
<p>对于一下函数参数得写法虽然不同，但是意义是一样得<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget <span class="keyword">const</span> * pw)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在 STL 中，如果希望迭代器所指的东西不可被改动， 可以使用 const_iterator</p>
<p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<p>返回一个 const 对象可以阻止这样的暴行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a*b) = c;</span><br></pre></td></tr></table></figure></p>
<h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>将 const 实施于成员函数的目的，是为了确认该成员函数可用作于 const 对象身上。</p>
<p>两个成员函数如果只是常量性(constness)不同，可以被重载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>成员函数如果是 const 意味着什么？<br>有两个流行的概念去解释： bitwise constness 以及 logical constness</p>
<h3 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const"></a>bitwise const</h3><p>成员函数只有在不更改对象的任何成员变量时才可以是const。<br>不幸的是，许多成员函数虽然不十足具备 const 性质却能通过 bitwise 测试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span>   <span class="comment">// bitwise const 声明</span></span><br><span class="line">    &#123; <span class="keyword">return</span> pText[<span class="built_in">position</span>]; &#125;                     <span class="comment">// 但其实不当</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;    <span class="comment">// 声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];               <span class="comment">// 调用const operator[]取得一个指针，指向cctb的数据</span></span><br><span class="line"></span><br><span class="line">*pc = <span class="string">'J'</span>;                         <span class="comment">// cctb 现在变成了"Jello"</span></span><br></pre></td></tr></table></figure>
<h3 id="logical-constness"><a href="#logical-constness" class="headerlink" title="logical constness"></a>logical constness</h3><p>一个 const 成员函数可以修改它所处理的对象内的某些 bits，但只有在客户端侦测不出的情况下才得如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">size_t</span> textLength;      <span class="comment">// 最近一次计算的文本区块长度</span></span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;     <span class="comment">// 目前的长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);     <span class="comment">// 错误！在 const 成员函数内不能赋值给 textLength 和 lengthIsValid</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以利用与 const 相关的摆动场： mutable(可变的)。<br>mutable 释放掉 non-static 成员变量的 bitwise constness 约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> textLength;      <span class="comment">// 这些成员变量可能总是会被更改</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;     <span class="comment">// 即使是在 const 成员函数内</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);     <span class="comment">// 此时编译器就不会报错了</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-const-和-non-const-成员函数中避免重复"><a href="#在-const-和-non-const-成员函数中避免重复" class="headerlink" title="在 const 和 non-const 成员函数中避免重复"></a>在 const 和 non-const 成员函数中避免重复</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验(bounds checking)</span></span><br><span class="line">        ... <span class="comment">// 志记数据访问(log access data)</span></span><br><span class="line">        ... <span class="comment">// 校验数据完整性(verify data integrity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验(bounds checking)</span></span><br><span class="line">        ... <span class="comment">// 志记数据访问(log access data)</span></span><br><span class="line">        ... <span class="comment">// 校验数据完整性(verify data integrity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然上面的代码出现了非常多的冗余，因此我们可以在 non-const operator[] 中调用 const operator[]<br>(思考：可以在const operator[] 中调用 non-const operator[]吗？)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验(bounds checking)</span></span><br><span class="line">        ... <span class="comment">// 志记数据访问(log access data)</span></span><br><span class="line">        ... <span class="comment">// 校验数据完整性(verify data integrity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(                                      <span class="comment">// 将 op[] 返回值的const转除</span></span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)                <span class="comment">// 为 *this 加上 const</span></span><br><span class="line">                    [<span class="built_in">position</span>]                                      <span class="comment">// 调用 const op[]</span></span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>将某些东西声明为 const 可帮助编译器侦测出错误用法。const 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施 bitwise constness，但编写程序时应当使用“概念上的常量性”(conceptual constness)</li>
<li>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用const版本可以避免代码重复。</li>
</ul>
<h3 id="条款04：-确定对象被使用前已被初始化"><a href="#条款04：-确定对象被使用前已被初始化" class="headerlink" title="条款04： 确定对象被使用前已被初始化"></a>条款04： 确定对象被使用前已被初始化</h3><ul>
<li>永远在使用对象之前先将它初始化。</li>
<li>确保每一个构造函数都将对象的每一个成员初始化。</li>
</ul>
<p>构造函数的一个比较好的写法就是：使用成员初始列(member initialization list)替换赋值动作。</p>
<p>为避免某些可能存在的晦涩的错误，当成员初值列中条列各个成员时，最好总是以其声明次序为次序。<br>这里晦涩错误是指，两个成员变量的初始化带有次序性。比如初始化array时要指定大小，因此代表大小的那个成员变量必须先有初值。</p>
<h3 id="不同编译单元内定义的-non-local-static-对象的初始化次序"><a href="#不同编译单元内定义的-non-local-static-对象的初始化次序" class="headerlink" title="不同编译单元内定义的 non-local static 对象的初始化次序"></a>不同编译单元内定义的 non-local static 对象的初始化次序</h3><p>假设有一个FileSystem class，它让互联网上的文件看起来好像位于本机(local)。<br>由于这个class使世界看起来像一个单一文件系统，所以需要一个特殊对象，位于global或者namespace作用域内，象征单一文件系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>              <span class="comment">// 位于你的程序库</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">FileSystem</span> tfs;          <span class="comment">// 预备给客户使用的对象， tfs 表示“the file system”</span></span><br></pre></td></tr></table></figure>
<p>现在假设某些客户建立了一个class用以处理文件系统内的目录(directories)，很自然他们的class会用上 theFileSystem 对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>               <span class="comment">// 由程序库客户建立</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Directory::Directory(params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> disks = tfs.numDisks();   <span class="comment">// 使用tfs对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;      <span class="comment">// 为临时文件而创建的目录</span></span><br></pre></td></tr></table></figure></p>
<p>此处 tfs 要在tempDir之前被初始化。但是tfs和tempDir是不同的人在不同时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的non-local static 对象。</p>
<p>正确的做法：将每一个 non-local static 对象搬到自己的专属函数内。<br>这些函数返回一个reference指向它所含的对象。然后用户直接调用这个函数，而不直接指涉这些对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>...&#125;;            <span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span>&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;                <span class="comment">// 这个函数用来替换 tfs 对象： 它在FileSystem class 中可能是个static。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;          <span class="comment">// 定义并初始化一个 local static 对象。</span></span><br><span class="line">    <span class="keyword">return</span> fs;                     <span class="comment">// 返回一个 reference 指向上述对象。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>...&#125;;</span><br><span class="line">Director::Directory(params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> disk = tfs().numDisks();     <span class="comment">// 原来是reference to tfs，现在是tfs()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span> </span>&#123;          <span class="comment">// 这个函数用来替换 tempDir 对象，他在Directory class 中可能是一个static</span></span><br><span class="line">    <span class="keyword">static</span> Directory td;        <span class="comment">// 定义并初始化一个 local static 对象</span></span><br><span class="line">    <span class="keyword">return</span> td;                  <span class="comment">// 返回一个reference指向上述对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>为内置类型对象进行手工初始化，因为c++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列(member initialization list),而不要在构造函数中使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和他们的声明次序相同。</li>
<li>为免除“跨编译单元的初始化次序”问题，请以local static 对象替换non-local static 对象。</li>
</ul>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款05：-了解-C-默默编写并调用哪些函数"><a href="#条款05：-了解-C-默默编写并调用哪些函数" class="headerlink" title="条款05： 了解 C++ 默默编写并调用哪些函数"></a>条款05： 了解 C++ 默默编写并调用哪些函数</h3><h3 id="条款06：-若不想使用编译器自动生成函数，就该明确拒绝"><a href="#条款06：-若不想使用编译器自动生成函数，就该明确拒绝" class="headerlink" title="条款06： 若不想使用编译器自动生成函数，就该明确拒绝"></a>条款06： 若不想使用编译器自动生成函数，就该明确拒绝</h3><h3 id="条款07：-为多态基类声明-virtual-析构函数"><a href="#条款07：-为多态基类声明-virtual-析构函数" class="headerlink" title="条款07： 为多态基类声明 virtual 析构函数"></a>条款07： 为多态基类声明 virtual 析构函数</h3><h3 id="条款08：-别让异常逃离析构函数"><a href="#条款08：-别让异常逃离析构函数" class="headerlink" title="条款08： 别让异常逃离析构函数"></a>条款08： 别让异常逃离析构函数</h3><h3 id="条款09：-绝不在构造和析构过程中调用-virtual-函数"><a href="#条款09：-绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款09： 绝不在构造和析构过程中调用 virtual 函数"></a>条款09： 绝不在构造和析构过程中调用 virtual 函数</h3><h3 id="条款10：-令-operator-返回一个-reference-to-this"><a href="#条款10：-令-operator-返回一个-reference-to-this" class="headerlink" title="条款10： 令 operator= 返回一个 reference to *this"></a>条款10： 令 operator= 返回一个 reference to *this</h3><h3 id="条款11：-在-operator-中处理“自我赋值”"><a href="#条款11：-在-operator-中处理“自我赋值”" class="headerlink" title="条款11： 在 operator= 中处理“自我赋值”"></a>条款11： 在 operator= 中处理“自我赋值”</h3><h3 id="条款12：-复制对象时勿忘其每一个成分"><a href="#条款12：-复制对象时勿忘其每一个成分" class="headerlink" title="条款12： 复制对象时勿忘其每一个成分"></a>条款12： 复制对象时勿忘其每一个成分</h3><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h2 id="定制-new-和-delete"><a href="#定制-new-和-delete" class="headerlink" title="定制 new 和 delete"></a>定制 new 和 delete</h2><h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/学习笔记/" rel="tag"># 学习笔记</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/17/Leetcode周赛/" rel="next" title="Leetcode周赛">
                <i class="fa fa-chevron-left"></i> Leetcode周赛
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/31/学习计划/" rel="prev" title="学习计划">
                学习计划 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/images.jpg" alt="Austin Deng">
            
              <p class="site-author-name" itemprop="name">Austin Deng</p>
              <p class="site-description motion-element" itemprop="description">凡心所向，素履以往；生如逆旅，一苇以航。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#让自己习惯C"><span class="nav-number">1.</span> <span class="nav-text">让自己习惯C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款01：-视-C-为一个语言联邦"><span class="nav-number">1.1.</span> <span class="nav-text">条款01： 视 C++ 为一个语言联邦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款02：-尽量以-const，enum，inline-替换-define"><span class="nav-number">1.2.</span> <span class="nav-text">条款02： 尽量以 const，enum，inline 替换 #define</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#emum-hack"><span class="nav-number">1.2.1.</span> <span class="nav-text">emum hack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-define实现宏-macros"><span class="nav-number">1.3.</span> <span class="nav-text">使用#define实现宏(macros)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款03：-尽可能使用-const"><span class="nav-number">1.5.</span> <span class="nav-text">条款03： 尽可能使用 const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-成员函数"><span class="nav-number">1.6.</span> <span class="nav-text">const 成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitwise-const"><span class="nav-number">1.7.</span> <span class="nav-text">bitwise const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logical-constness"><span class="nav-number">1.8.</span> <span class="nav-text">logical constness</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-const-和-non-const-成员函数中避免重复"><span class="nav-number">1.9.</span> <span class="nav-text">在 const 和 non-const 成员函数中避免重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结："><span class="nav-number">1.10.</span> <span class="nav-text">总结：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款04：-确定对象被使用前已被初始化"><span class="nav-number">1.11.</span> <span class="nav-text">条款04： 确定对象被使用前已被初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同编译单元内定义的-non-local-static-对象的初始化次序"><span class="nav-number">1.12.</span> <span class="nav-text">不同编译单元内定义的 non-local static 对象的初始化次序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-1"><span class="nav-number">1.13.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造-析构-赋值运算"><span class="nav-number">2.</span> <span class="nav-text">构造/析构/赋值运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款05：-了解-C-默默编写并调用哪些函数"><span class="nav-number">2.1.</span> <span class="nav-text">条款05： 了解 C++ 默默编写并调用哪些函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款06：-若不想使用编译器自动生成函数，就该明确拒绝"><span class="nav-number">2.2.</span> <span class="nav-text">条款06： 若不想使用编译器自动生成函数，就该明确拒绝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款07：-为多态基类声明-virtual-析构函数"><span class="nav-number">2.3.</span> <span class="nav-text">条款07： 为多态基类声明 virtual 析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款08：-别让异常逃离析构函数"><span class="nav-number">2.4.</span> <span class="nav-text">条款08： 别让异常逃离析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款09：-绝不在构造和析构过程中调用-virtual-函数"><span class="nav-number">2.5.</span> <span class="nav-text">条款09： 绝不在构造和析构过程中调用 virtual 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款10：-令-operator-返回一个-reference-to-this"><span class="nav-number">2.6.</span> <span class="nav-text">条款10： 令 operator= 返回一个 reference to *this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款11：-在-operator-中处理“自我赋值”"><span class="nav-number">2.7.</span> <span class="nav-text">条款11： 在 operator= 中处理“自我赋值”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款12：-复制对象时勿忘其每一个成分"><span class="nav-number">2.8.</span> <span class="nav-text">条款12： 复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源管理"><span class="nav-number">3.</span> <span class="nav-text">资源管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计与声明"><span class="nav-number">4.</span> <span class="nav-text">设计与声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">5.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承与面向对象设计"><span class="nav-number">6.</span> <span class="nav-text">继承与面向对象设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板与泛型编程"><span class="nav-number">7.</span> <span class="nav-text">模板与泛型编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制-new-和-delete"><span class="nav-number">8.</span> <span class="nav-text">定制 new 和 delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杂项讨论"><span class="nav-number">9.</span> <span class="nav-text">杂项讨论</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Austin Deng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
