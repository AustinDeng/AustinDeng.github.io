<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习笔记,C++,">










<meta name="description" content="让自己习惯C++条款01： 视 C++ 为一个语言联邦C++ 包含了多种泛型编程：  过程形式 面向对象形式 函数形式 泛型形式 元编程形式  将C++视作一个由相关语言组成的联邦而非单一语言：  C。 区块、语句、预处理器、内置数据类型、数组、指针 没有模板、没有异常、没有重载   Object-Oriented C++。 类、封装、继承、多态、virtual函数(动态绑定)   Templat">
<meta name="keywords" content="学习笔记,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective C++》学习笔记">
<meta property="og:url" content="http://yoursite.com/2021/05/28/《Effective-C-》学习笔记/index.html">
<meta property="og:site_name" content="邓某的杂货铺">
<meta property="og:description" content="让自己习惯C++条款01： 视 C++ 为一个语言联邦C++ 包含了多种泛型编程：  过程形式 面向对象形式 函数形式 泛型形式 元编程形式  将C++视作一个由相关语言组成的联邦而非单一语言：  C。 区块、语句、预处理器、内置数据类型、数组、指针 没有模板、没有异常、没有重载   Object-Oriented C++。 类、封装、继承、多态、virtual函数(动态绑定)   Templat">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-08-22T15:11:26.909Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Effective C++》学习笔记">
<meta name="twitter:description" content="让自己习惯C++条款01： 视 C++ 为一个语言联邦C++ 包含了多种泛型编程：  过程形式 面向对象形式 函数形式 泛型形式 元编程形式  将C++视作一个由相关语言组成的联邦而非单一语言：  C。 区块、语句、预处理器、内置数据类型、数组、指针 没有模板、没有异常、没有重载   Object-Oriented C++。 类、封装、继承、多态、virtual函数(动态绑定)   Templat">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/28/《Effective-C-》学习笔记/">





  <title>《Effective C++》学习笔记 | 邓某的杂货铺</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">邓某的杂货铺</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">凡心所向，素履以往；生如逆旅，一苇以航。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/28/《Effective-C-》学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Austin Deng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邓某的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Effective C++》学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-28T18:53:13+08:00">
                2021-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：-视-C-为一个语言联邦"><a href="#条款01：-视-C-为一个语言联邦" class="headerlink" title="条款01： 视 C++ 为一个语言联邦"></a>条款01： 视 C++ 为一个语言联邦</h3><p>C++ 包含了多种泛型编程：</p>
<ul>
<li>过程形式</li>
<li>面向对象形式</li>
<li>函数形式</li>
<li>泛型形式</li>
<li>元编程形式</li>
</ul>
<p>将C++视作一个由相关语言组成的联邦而非单一语言：</p>
<ul>
<li>C。<ul>
<li>区块、语句、预处理器、内置数据类型、数组、指针</li>
<li>没有模板、没有异常、没有重载</li>
</ul>
</li>
<li>Object-Oriented C++。<ul>
<li>类、封装、继承、多态、virtual函数(动态绑定)</li>
</ul>
</li>
<li>Template C++：<ul>
<li>泛型编程</li>
<li>template metaprogramming(TMP 模板元编程)</li>
</ul>
</li>
<li>STL</li>
</ul>
<p>C++ 高效编程守则视状况而变化，取决于你使用C++哪一部分。</p>
<a id="more"></a>
<h3 id="条款02：-尽量以-const，enum，inline-替换-define"><a href="#条款02：-尽量以-const，enum，inline-替换-define" class="headerlink" title="条款02： 尽量以 const，enum，inline 替换 #define"></a>条款02： 尽量以 const，enum，inline 替换 #define</h3><p>将 <code>#define ASPECT_RATIO 1.653</code>替换为<code>const double AspectRatio = 1.653</code></p>
<p>定义一个常量的<code>char*-based</code>字符串<br>将<code>const char* const authorName = &quot;Scott Meyers&quot;;</code>替换为<code>const std::string authorName(&quot;Scott Meyers&quot;);</code></p>
<p>我们无法利用<code>#define</code>创建一个 <code>class</code>专属常量，因为<code>#define</code>并不重视作用域(scope)</p>
<h4 id="emum-hack"><a href="#emum-hack" class="headerlink" title="emum hack"></a>emum hack</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurn = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurn];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于编译器坚持必须在编译期间知道数组大小，可能导致编译器(错误地)不允许“static 整数型 class 常量”完成“in class 初值设定”</p>
<p>所以可以这么做<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurn = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurn];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enum hack 的行为某方面更像#define而不像const。<br>例如：取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址也不合法。</p>
<h4 id="使用-define实现宏-macros"><a href="#使用-define实现宏-macros" class="headerlink" title="使用#define实现宏(macros)"></a>使用<code>#define</code>实现宏(macros)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 a 和 b 的较大值调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p>会遇到这样的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);     <span class="comment">// a 被累加二次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);  <span class="comment">// a 被累加一次</span></span><br></pre></td></tr></table></figure>
<p>只要用 template inline 解决即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;    <span class="comment">// 由于不知道T是什么，所以采用 pass by reference-to-const</span></span><br><span class="line">    f(a &gt; b ? a: b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对于单纯常量，最好以 const 对象或 enums 替换 #define</li>
<li>对于形似函数的宏(macros),最好改用inline函数替换 #defines</li>
</ul>
<h3 id="条款03：-尽可能使用-const"><a href="#条款03：-尽可能使用-const" class="headerlink" title="条款03： 尽可能使用 const"></a>条款03： 尽可能使用 const</h3><p>面对指针，你可以指出指针自身、指针所指物，或者两者都（或都不）是const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;         </span><br><span class="line"><span class="keyword">char</span>* p = greeting;                <span class="comment">// non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;          <span class="comment">// non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;          <span class="comment">// const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;    <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>如果关键字 const 出现在星号左边，说明被指物是常量<br>如果关键字 const 出现在星号右边，说明指针自身是常量<br>如果关键字 const 出现在星号两边，说明被指物和指针两者都是常量</p>
<p>对于一下函数参数得写法虽然不同，但是意义是一样得<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget <span class="keyword">const</span> * pw)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在 STL 中，如果希望迭代器所指的东西不可被改动， 可以使用 const_iterator</p>
<p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<p>返回一个 const 对象可以阻止这样的暴行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a*b) = c;</span><br></pre></td></tr></table></figure></p>
<h4 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h4><p>将 const 实施于成员函数的目的，是为了确认该成员函数可用作于 const 对象身上。</p>
<p>两个成员函数如果只是常量性(constness)不同，可以被重载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>成员函数如果是 const 意味着什么？<br>有两个流行的概念去解释： bitwise constness 以及 logical constness</p>
<h4 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const"></a>bitwise const</h4><p>成员函数只有在不更改对象的任何成员变量时才可以是const。<br>不幸的是，许多成员函数虽然不十足具备 const 性质却能通过 bitwise 测试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span>   <span class="comment">// bitwise const 声明</span></span><br><span class="line">    &#123; <span class="keyword">return</span> pText[<span class="built_in">position</span>]; &#125;                     <span class="comment">// 但其实不当</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;    <span class="comment">// 声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];               <span class="comment">// 调用const operator[]取得一个指针，指向cctb的数据</span></span><br><span class="line"></span><br><span class="line">*pc = <span class="string">'J'</span>;                         <span class="comment">// cctb 现在变成了"Jello"</span></span><br></pre></td></tr></table></figure>
<h4 id="logical-constness"><a href="#logical-constness" class="headerlink" title="logical constness"></a>logical constness</h4><p>一个 const 成员函数可以修改它所处理的对象内的某些 bits，但只有在客户端侦测不出的情况下才得如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">size_t</span> textLength;      <span class="comment">// 最近一次计算的文本区块长度</span></span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;     <span class="comment">// 目前的长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);     <span class="comment">// 错误！在 const 成员函数内不能赋值给 textLength 和 lengthIsValid</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以利用与 const 相关的摆动场： mutable(可变的)。<br>mutable 释放掉 non-static 成员变量的 bitwise constness 约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> textLength;      <span class="comment">// 这些成员变量可能总是会被更改</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;     <span class="comment">// 即使是在 const 成员函数内</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);     <span class="comment">// 此时编译器就不会报错了</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-const-和-non-const-成员函数中避免重复"><a href="#在-const-和-non-const-成员函数中避免重复" class="headerlink" title="在 const 和 non-const 成员函数中避免重复"></a>在 const 和 non-const 成员函数中避免重复</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验(bounds checking)</span></span><br><span class="line">        ... <span class="comment">// 志记数据访问(log access data)</span></span><br><span class="line">        ... <span class="comment">// 校验数据完整性(verify data integrity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验(bounds checking)</span></span><br><span class="line">        ... <span class="comment">// 志记数据访问(log access data)</span></span><br><span class="line">        ... <span class="comment">// 校验数据完整性(verify data integrity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然上面的代码出现了非常多的冗余，因此我们可以在 non-const operator[] 中调用 const operator[]<br>(思考：可以在const operator[] 中调用 non-const operator[]吗？)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验(bounds checking)</span></span><br><span class="line">        ... <span class="comment">// 志记数据访问(log access data)</span></span><br><span class="line">        ... <span class="comment">// 校验数据完整性(verify data integrity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(                                      <span class="comment">// 将 op[] 返回值的const转除</span></span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)                <span class="comment">// 为 *this 加上 const</span></span><br><span class="line">                    [<span class="built_in">position</span>]                                      <span class="comment">// 调用 const op[]</span></span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>将某些东西声明为 const 可帮助编译器侦测出错误用法。const 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施 bitwise constness，但编写程序时应当使用“概念上的常量性”(conceptual constness)</li>
<li>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用const版本可以避免代码重复。</li>
</ul>
<h3 id="条款04：-确定对象被使用前已被初始化"><a href="#条款04：-确定对象被使用前已被初始化" class="headerlink" title="条款04： 确定对象被使用前已被初始化"></a>条款04： 确定对象被使用前已被初始化</h3><ul>
<li>永远在使用对象之前先将它初始化。</li>
<li>确保每一个构造函数都将对象的每一个成员初始化。</li>
</ul>
<p>构造函数的一个比较好的写法就是：使用成员初始列(member initialization list)替换赋值动作。</p>
<p>为避免某些可能存在的晦涩的错误，当成员初值列中条列各个成员时，最好总是以其声明次序为次序。<br>这里晦涩错误是指，两个成员变量的初始化带有次序性。比如初始化array时要指定大小，因此代表大小的那个成员变量必须先有初值。</p>
<h4 id="不同编译单元内定义的-non-local-static-对象的初始化次序"><a href="#不同编译单元内定义的-non-local-static-对象的初始化次序" class="headerlink" title="不同编译单元内定义的 non-local static 对象的初始化次序"></a>不同编译单元内定义的 non-local static 对象的初始化次序</h4><p>假设有一个FileSystem class，它让互联网上的文件看起来好像位于本机(local)。<br>由于这个class使世界看起来像一个单一文件系统，所以需要一个特殊对象，位于global或者namespace作用域内，象征单一文件系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>              <span class="comment">// 位于你的程序库</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">FileSystem</span> tfs;          <span class="comment">// 预备给客户使用的对象， tfs 表示“the file system”</span></span><br></pre></td></tr></table></figure>
<p>现在假设某些客户建立了一个class用以处理文件系统内的目录(directories)，很自然他们的class会用上 theFileSystem 对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>               <span class="comment">// 由程序库客户建立</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Directory::Directory(params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> disks = tfs.numDisks();   <span class="comment">// 使用tfs对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;      <span class="comment">// 为临时文件而创建的目录</span></span><br></pre></td></tr></table></figure></p>
<p>此处 tfs 要在tempDir之前被初始化。但是tfs和tempDir是不同的人在不同时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的non-local static 对象。</p>
<p>正确的做法：将每一个 non-local static 对象搬到自己的专属函数内。<br>这些函数返回一个reference指向它所含的对象。然后用户直接调用这个函数，而不直接指涉这些对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>...&#125;;            <span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span>&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;                <span class="comment">// 这个函数用来替换 tfs 对象： 它在FileSystem class 中可能是个static。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;          <span class="comment">// 定义并初始化一个 local static 对象。</span></span><br><span class="line">    <span class="keyword">return</span> fs;                     <span class="comment">// 返回一个 reference 指向上述对象。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>...&#125;;</span><br><span class="line">Director::Directory(params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> disk = tfs().numDisks();     <span class="comment">// 原来是reference to tfs，现在是tfs()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span> </span>&#123;          <span class="comment">// 这个函数用来替换 tempDir 对象，他在Directory class 中可能是一个static</span></span><br><span class="line">    <span class="keyword">static</span> Directory td;        <span class="comment">// 定义并初始化一个 local static 对象</span></span><br><span class="line">    <span class="keyword">return</span> td;                  <span class="comment">// 返回一个reference指向上述对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>为内置类型对象进行手工初始化，因为c++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列(member initialization list),而不要在构造函数中使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和他们的声明次序相同。</li>
<li>为免除“跨编译单元的初始化次序”问题，请以local static 对象替换non-local static 对象。</li>
</ul>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款05：-了解-C-默默编写并调用哪些函数"><a href="#条款05：-了解-C-默默编写并调用哪些函数" class="headerlink" title="条款05： 了解 C++ 默默编写并调用哪些函数"></a>条款05： 了解 C++ 默默编写并调用哪些函数</h3><p>当你声明一个空类时，C++的编译器会默认给你声明一个 copy 构造函数、一个copy assignment 操作符以及一个析构函数<br>若没有声明任何构造函数，编译器也会声明一个 default 构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码等同于下述代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;                                 <span class="comment">// default构造函数</span></span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;                 <span class="comment">// copy构造函数</span></span><br><span class="line">    ~Empty() &#123; ... &#125;                                <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;     <span class="comment">// copy assignment操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思考如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注意这里的 name 是一个 reference-to-non-const 的string类型</span></span><br><span class="line">    NameObject(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    ...   <span class="comment">// 此处没有声明 operator=</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// reference</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="comment">// const</span></span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行下面这个代码时，会发生一些什么问题？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">newDog</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">oldDog</span><span class="params">(<span class="string">"Satch"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">nameObject&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">nameObject&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(oldDog, <span class="number">36</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p = s;</span><br></pre></td></tr></table></figure>
<ul>
<li>p.nameValue 和 s.nameValue 指向不同的 string 对象</li>
<li>执行赋值后，p.nameValue 会指向 s.nameValue吗？</li>
<li>如果是，则 reference 自身被改动了，但是在C++中，不允许“让 reference 改指向不同对象”</li>
<li>若允许“改 reference 指向”, 则会导致修改一个对象，其他reference该对象的都会受到影响</li>
</ul>
<p>针对以上问题，编译器拒绝回答，即编译到赋值时，拒绝编译！</p>
<p>因此，在C++中：</p>
<ul>
<li>如果打算在一个“内涵reference 成员”的class内支持赋值操作(assignment)，你必须定义 copy assignment操作符</li>
<li>同理，对于“内涵 const 成员”也是一样的</li>
<li>若某个 base classes 将 copy assignment操作符声明为private，编译器将拒绝为其derived classes 生成一个 copy assignment 操作符</li>
</ul>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>编译器可以暗自为 class 创建 default 构造函数、copy构造函数、copy assignment操作符以及析构函数</li>
</ul>
<h3 id="条款06：-若不想使用编译器自动生成函数，就该明确拒绝"><a href="#条款06：-若不想使用编译器自动生成函数，就该明确拒绝" class="headerlink" title="条款06： 若不想使用编译器自动生成函数，就该明确拒绝"></a>条款06： 若不想使用编译器自动生成函数，就该明确拒绝</h3><p>编译器默认创建的函数都是 public 类型的<br>若不想使用编译器自动生成的函数且不想被调用，可以自己声明并声明类型为private<br>如此：既阻止了编译器暗自创建其专属版本，又组织了其他人的调用</p>
<p>但是这个方法并不绝对安全，因为 member 函数和friend函数依然可以调用private函数，如果真有此事，连接器会发出错误</p>
<p>可以通过以下方法，将连接期的错误移到编译器：<br>在一个专门为阻止copying动作而设计的base class 内，将 copy 构造函数和copy assignment操作符声明为private</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:              <span class="comment">// 允许 derived 对象构造和析构</span></span><br><span class="line">    Uncopyable() &#123; &#125;</span><br><span class="line">    ~Uncopyable() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable (<span class="keyword">const</span> Uncopyable&amp;);     <span class="comment">// 但是阻止拷贝</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在阻止copying的对象中继承这个类即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span> <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>为了驳回编译器自动(暗自)提供的机能，可将相应的成员函数声明为private并且不予实现。</li>
<li>使用像 Uncopyable 这样的 base classes 也是一种做法</li>
</ul>
<h3 id="条款07：-为多态基类声明-virtual-析构函数"><a href="#条款07：-为多态基类声明-virtual-析构函数" class="headerlink" title="条款07： 为多态基类声明 virtual 析构函数"></a>条款07： 为多态基类声明 virtual 析构函数</h3><p>对于一个多态的基类，如果它的析构函数不是 virtual 的话，会有资源泄漏，败坏数据结构的风险</p>
<p>思考如下关于多态的时钟的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">// 原子钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;   <span class="comment">// 水钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WristWatch</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;   <span class="comment">// 腕表</span></span><br></pre></td></tr></table></figure>
<p>由于客户只想在程序中使用时间，而不操心时间的设计细节<br>于是可以使用一个工厂(factory)函数，返回指针指向一个计时对象</p>
<p>Factor 函数返回一个base class 指针，指向新生成的derived class 对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeKeeper* <span class="title">getTimeKeeper</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后，观察下面这个代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeKeeper* ptk = getTimeKeeper();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>
<p>会产生这样一个问题：<br>getTimeKeeper 返回的指针指向一个 derived class 对象(例如AtomicClock)<br>而那个对象却经由一个base 指针(例如一个TimeKeeper*指针)被删除，而目前的base class(TimeKeeper)有个non-virtual函数</p>
<p>C++明确指出：<br>当derived class 对象经由一个base class指针被删除，而该base class 带着一个non-virtual析构函数，其结果未有定义————实际执行时通常发生的是对象的derived成分没有被销毁(仅仅销毁了base class)</p>
<p>解决方法就是给base class 加上一个virtual析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    <span class="keyword">virtual</span> ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TimeKeeper* ptk = getTimeKeeper();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>
<p>当class不企图被当作base class时，令其析构函数为virtual往往是一个馊主意。<br>由于虚函数表机制，这样会导致占用额外的空间，也会导致缺乏移植性<br>所以，只有当class内含有至少一个virtual函数，才为它声明virtual析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 馊主意，因为std::string 有一个non-virtual析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialString</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">string</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpecialString* pss = <span class="keyword">new</span> SpecialString(<span class="string">"Impending Doom"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* ps;</span><br><span class="line">...</span><br><span class="line">ps = pss;           <span class="comment">// SpecialString* =&gt; std::string</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;          <span class="comment">// 未有定义！现实中*ps的SpecialString资源会泄漏，因为SpecialString析构函数没有被调用</span></span><br></pre></td></tr></table></figure>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>为你希望它成为抽象的那个class声明一个pure virtual 析构函数</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li>polymorphic(带多态性质的) base classes 应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</li>
<li>Classes 的设计目的如果不是作为base classes使用，或不是为了具有多态性(polymorphically)，就不应该声明 virtual析构函数</li>
</ul>
<h3 id="条款08：-别让异常逃离析构函数"><a href="#条款08：-别让异常逃离析构函数" class="headerlink" title="条款08： 别让异常逃离析构函数"></a>条款08： 别让异常逃离析构函数</h3><p>C++不喜欢在析构时吐出异常<br>考虑一个对象数组，数组中的每一个元素是一个对象，当对象在析构的时候如果产生异常，那么这是一件不确定行为，可能会产生资源泄漏</p>
<p>两种办法解决：</p>
<ul>
<li><p>如果close抛出异常就结束程序。通常通过abort完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        执行运转记录，记录下对<span class="built_in">close</span>的调用失败;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>吞下因调用close而发生的异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        执行运转记录，记录下对<span class="built_in">close</span>的调用失败;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还有一个较好的策略是重新设计DBConn接口，使得客户有机会对可能出现的问题作出反应</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吐下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行操作</li>
</ul>
<h3 id="条款09：-绝不在构造和析构过程中调用-virtual-函数"><a href="#条款09：-绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款09： 绝不在构造和析构过程中调用 virtual 函数"></a>条款09： 绝不在构造和析构过程中调用 virtual 函数</h3><p>不要在构造函数和析构函数期间调用 virtual 函数，因为这样会带来预想不到的结果</p>
<p>假设一个class继承体系，用来表示股市交易，交易有一步是需要审计，所以每当创建一个对象时，需要在审计日志(audit log)中创建一笔适当的记录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有交易的 base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction();</span><br><span class="line">    <span class="comment">// 因类型不同而不同的类型记录，多态性</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// base class 的构造函数</span></span><br><span class="line">Transaction::Transaction() &#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，执行下面这个代码，会发生不符合预期的效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure></p>
<p>我都知道，构造函数的调用顺序是从内而外的，代码会先调用base class的构造函数，在调用base class构造函数的时候，会调用virtual 的logTransaction.<br>注意！此时的logTransaction是Transaction内版本，而不是BugTransaction内的版本<br>但是我们现在是在建立BuyTransaction的对象类型</p>
<p>同样的道理也适用于析构函数。<br>一旦derived class析构函数开始执行，对象内的derived class成员变量便呈未定义值</p>
<p>一个解决方案是在 class Transaction 内将logTransaction改为non-virtual，然后要求derived class 构造函数传递必要信息给Transaction构造函数，而后那个构造函数便可以安全地调用non-virtual logTransaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="comment">// 如今是一个 non-virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span> <span class="keyword">const</span></span>;   </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo) &#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">// 将log信息传递给base class构造函数</span></span><br><span class="line">    BuyTransaction(parameters) : Transaction(createLogString(parameters)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class</li>
</ul>
<h3 id="条款10：-令-operator-返回一个-reference-to-this"><a href="#条款10：-令-operator-返回一个-reference-to-this" class="headerlink" title="条款10： 令 operator= 返回一个 reference to *this"></a>条款10： 令 operator= 返回一个 reference to *this</h3><p>为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。<br>这是你为classes实现赋值操作符时应该遵循的协议</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span> rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul>
<li>令赋值(assignment)操作符返回一个reference to *this。</li>
</ul>
<h3 id="条款11：-在-operator-中处理“自我赋值”"><a href="#条款11：-在-operator-中处理“自我赋值”" class="headerlink" title="条款11： 在 operator= 中处理“自我赋值”"></a>条款11： 在 operator= 中处理“自我赋值”</h3><p>自我赋值看起来很愚蠢<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;</span><br></pre></td></tr></table></figure></p>
<p>但是有时候潜在的自我赋值却未必能避免</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];</span><br><span class="line">*px = *py</span><br></pre></td></tr></table></figure>
<p>如果你尝试自行管理资源，可能会掉入“在停止使用资源之前意外释放了它”的陷阱”。</p>
<p>考虑创建一个class用来保存一个指针指向一块动态分配的位图(bitmap)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指针，指向一个从 heap 分配而得的对象</span></span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator= 实现代码，看起来合理，但是自我赋值出现时并不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 停止使用当前的bitmap</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="comment">// 使用rhs’s bitmap 的副本</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的问题是，当自我赋值产生时，operator= 函数内的*this 和rhs有可能是同一对象<br>那么delete就不只销毁当前对象的bitmap，也销毁了rhs的bitmap</p>
<p>传统方法是增加一个“证同测试”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 证同测试</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止使用当前的bitmap</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="comment">// 使用rhs’s bitmap 的副本</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果“new bitmap”导致异常(内存不足或者Bitmap copy构造函数抛出异常)<br>Widget最终会持有一个指针指向一块被删除的Bitmap<br>这样的指针是有害的，我们无法安全地删除它们，甚至无法安全地读取它们。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 记住原先的pb</span></span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    <span class="comment">// 令pb指向*pb的一个复制</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="comment">// 删除原先的pb</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果“new Bitmap”抛出异常，pb保持原状。及时没有证同测试，这段代码还是可以处理自我赋值</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul>
<li>确保当对象自我赋值时operator= 有良好的行为。其中技术包括“来源对象”和“目标对象”的地址、精心周到的语句顺序以及copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
<h3 id="条款12：-复制对象时勿忘其每一个成分"><a href="#条款12：-复制对象时勿忘其每一个成分" class="headerlink" title="条款12： 复制对象时勿忘其每一个成分"></a>条款12： 复制对象时勿忘其每一个成分</h3><p>考虑一个class用来表现客户，其中手工设计实现一个copying函数(而不是由编译器创建)，使得外界对它们的调用会被记录(logged)下来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log entry</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logCall</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; funcName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs) : name(rhs.name) &#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy assignment operator"</span>);</span><br><span class="line">    name = rhs.name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止一切都很好，直到加入另外一个成员变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span> ... &#125;;   <span class="comment">// 日期</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...             <span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候请注意了，上面的copying函数就变成了局部拷贝了，只拷贝了name而缺少了Transaction<br>而编译器也不会提醒你这个事实</p>
<p>一旦继承发生，就有潜藏危机</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs) : priority(rhs.priority) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>= (<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PriorityCustomer 的 copying 函数复制了PriorityCustomer声明的成员变量<br>但是每个PriorityCustomer还内含了它继承的 Customer 成员变量的副本，而这些成员变量却未被复制<br>default构造函数将对 name 和 lastTransaction执行缺省的初始化操作</p>
<p>应该让derived class的copying函数调用相应的base class 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个操作：调用 base class 的copy构造函数</span></span><br><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs) : Customer(rhs), priority(rhs.priority) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>= (<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    <span class="comment">// 对 base class 成分进行赋值操作</span></span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Copying 函数应该确保复制“对象内的所有成员变量”以及“所有base class 成分”</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应该将共同既能放在第三个函数中，并由两个coping函数共同调用。</li>
</ul>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：-以对象管理资源"><a href="#条款13：-以对象管理资源" class="headerlink" title="条款13： 以对象管理资源"></a>条款13： 以对象管理资源</h3><p>对一个投资行为进行建模</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指针，指向Investment继承体系内的动态分配对象，调用者负责删除它</span></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在考虑使用f()来负责删除createInvestment返回的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Investment* pInv = createInvestment(); </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，最后一条语句未必可以执行到，因为在此之前就返回或者函数抛出异常，这样就产生了资源泄漏</p>
<p>为了确保createInvestment返回的资源总是可以被释放，我们需要将资源放进对象内<br>依赖于C++中的“析构函数自动调用机制”确保资源被释放</p>
<p>auto_ptr是一个特殊“类指针(pointer-like)对象”，即所谓的智能指针<br>其析构函数自动对其所指对象调用delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line">    ...     <span class="comment">// 经由auto_ptr的析构函数自动删除pInv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“以对象管理资源”的两个关键想法：</p>
<ul>
<li>获得资源后立刻放进对象</li>
<li>管理对象运行析构函数确保资源被释放</li>
</ul>
<p>C++有个底层条件：受auto_ptrs管理的资源必须绝对没有一个以上的auto_ptr同时指向它<br>否则，对象被删除一次以上，就会造成“未定义行为”</p>
<p>auto_ptr的替代方案是“引用计数型智能指针”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 auto_ptr 和 tr1::shared_prt两者都在析构函数内做delete而不是delete[]</p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul>
<li>为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>两个常被使用的RAII classes 分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向null</li>
</ul>
<h3 id="条款14：-在资源管理类中小心-copying-行为"><a href="#条款14：-在资源管理类中小心-copying-行为" class="headerlink" title="条款14： 在资源管理类中小心 copying 行为"></a>条款14： 在资源管理类中小心 copying 行为</h3><p>有时候需要你自己建立一个资源管理类</p>
<p>假设建立一个class来管理锁机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : <span class="title">mutexPtr</span><span class="params">(pm)</span> </span>&#123;</span><br><span class="line">            lock(mutexPtr);</span><br><span class="line">        &#125;</span><br><span class="line">        ~Lock() &#123;</span><br><span class="line">            unlock(mutexPtr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">｛</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<p>但是如果RAII对象被复制，则需要考虑两点</p>
<ul>
<li>禁止复制</li>
<li>对底层资源使用“引用计数法”</li>
</ul>
<p>使用tr1::shared_ptr时，计数器为0时，资源会被删除，但是我们可以对其指定自定义“删除器”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : <span class="title">mutexPtr</span><span class="params">(pm, unlock)</span> </span>&#123;</span><br><span class="line">            lock(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        ~Lock() &#123;</span><br><span class="line">            unlock(mutexPtr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为</li>
<li>普通而常见的 RAII class copying 行为是： 抑制 copying、施行引用计数法。不过其他行为也都可能被实现。</li>
</ul>
<h3 id="条款15：-在资源管理类中提供对原始资源的访问"><a href="#条款15：-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15： 在资源管理类中提供对原始资源的访问"></a>条款15： 在资源管理类中提供对原始资源的访问</h3><p>由于许多APIs需要直接使用原始资源，所以RAII不得不提供一个访问原始资源的办法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;   <span class="comment">// 返回投资的天数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = daysHeld(pIbv);   <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行编译不通过，因为daysHeld需要的是Investment*指针，但是却传了一个tr1::shared_ptr<investment>对象</investment></p>
<p>因此我们需要一个函数将RAII 对象转换成原始资源</p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> days = daysHeld(pInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>tr1::shared_prt 和 auto_prt 重载了指针取值操作符(operator-&gt; 和 operator*)，允许隐式转换至底部的原始指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">tr1::shared_prt&lt;Investment&gt; <span class="title">pil</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="keyword">bool</span> taxablel = !(pil-&gt;isTaxFree());</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="keyword">bool</span> taxable2 = !((*pi2).isTaxFree());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>APIs往往要求访问原始资源(raw resources),所以每一个RAII class应该提供一个“取得其管理的资源”的办法</li>
<li>对原始资源的访问可能经由显式转换或者隐式转换。一般而言显式转换比较安全，但隐式转换对客户更加方便</li>
</ul>
<h3 id="条款16：-成对使用-new-和-delete-时要采取相同形式"><a href="#条款16：-成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款16： 成对使用 new 和 delete 时要采取相同形式"></a>条款16： 成对使用 new 和 delete 时要采取相同形式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringArray = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringArray;</span><br></pre></td></tr></table></figure>
<p>以上这个代码中，string数组中至少有99个对象不太可能被适当删除，因为它们的析构函数没有被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPrt2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="keyword">delete</span> [ ] stringPtr2;</span><br></pre></td></tr></table></figure>
<p>尽量不要对数组形式做typedefs动作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> AddressLines[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处返回一个string*，即“new string[4]”</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pal = <span class="keyword">new</span> AddressLines;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;         <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span> [ ] pal;     <span class="comment">// 很好！</span></span><br></pre></td></tr></table></figure>
<h4 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>如果你在new表达式中使用<code>[]</code>，必须在相应的delete表达式中也使用<code>[]</code></li>
<li>如果你在new表达式中不使用<code>[]</code>，一定不要在相应的detele表达式中使用<code>[]</code></li>
</ul>
<h3 id="条款17：-以独立语句将-newed-对象置入智能指针"><a href="#条款17：-以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款17： 以独立语句将 newed 对象置入智能指针"></a>条款17： 以独立语句将 newed 对象置入智能指针</h3><p>假设一个函数用于处理程序优先权，另一个函数用来动态分配所得的Widget上进行某些带有优先权的处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当我们调用时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure>
<p>显然编译不通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>
<p>现在编译通过了，编译在调用processWidget会做三件事</p>
<ol>
<li>调用priority</li>
<li>执行”new Widget”</li>
<li>调用tr1::shared_ptr构造函数</li>
</ol>
<p>操作2肯定会在操作3之前执行，但是操作1在什么时候执行这个问题弹性很大</p>
<p>假设按以下顺序执行，就有可能资源泄漏</p>
<ol>
<li>执行”new Widget”</li>
<li>调用priority</li>
<li>调用tr1::shared_ptr构造函数</li>
</ol>
<p>万一调用priority时，抛出异常，“new Widget”的指针将会遗失</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"></span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>
<h4 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h4><p>以独立语句将 newed 对象存储于(置入)智能指针内。如果不这样做，一旦异常被抛出，有可能难以擦觉资源泄漏</p>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：-让接口容易被正确使用，不易被误用"><a href="#条款18：-让接口容易被正确使用，不易被误用" class="headerlink" title="条款18： 让接口容易被正确使用，不易被误用"></a>条款18： 让接口容易被正确使用，不易被误用</h3><p>理想上，如果客户企图使用某个接口却没有获得预期效果，这个代码不该通过编译；如果代码通过了编译，它的作为就是该客户所想要的。</p>
<p>可以使用导入简单的外覆类型(wrapper types)来区别年月日</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="keyword">int</span> d)</span> :<span class="title">val</span><span class="params">(d)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span> :<span class="title">val</span><span class="params">(m)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Year</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="keyword">int</span> y)</span> :<span class="title">val</span><span class="params">(y)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Date(<span class="keyword">const</span> Month&amp; m, <span class="keyword">const</span> Day&amp; d, <span class="keyword">const</span> Year&amp; y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>;  <span class="comment">// 编译不通过</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">3</span>), Year(<span class="number">1995</span>))</span></span>;   <span class="comment">// 编译不通过</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;   <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p>对于值得有效性检验可以使用enums，但是不具备类型安全性<br>比较安全的做法是预先定义所有有效的Months</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Jan</span><span class="params">()</span> <span class="keyword">return</span> <span class="title">Month</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Feb</span><span class="params">()</span> <span class="keyword">return</span> <span class="title">Month</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Dec</span><span class="params">()</span> <span class="keyword">return</span> <span class="title">Month</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Mar(), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>好的接口很容易被正确使用，不容易被误用。你应该在你所有接口中努力达成这些性质</li>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
<li>tr1::shared_ptr支持定制型删除器(custom deleter)。这可以防范DLL问题，可被用来自动解除互斥锁等等。</li>
</ul>
<h3 id="条款19：-设计-class-犹如设计-type"><a href="#条款19：-设计-class-犹如设计-type" class="headerlink" title="条款19： 设计 class 犹如设计 type"></a>条款19： 设计 class 犹如设计 type</h3><p>如何设计高效的 classes?你需要思考一下一些问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁</li>
<li>对象的初始化和对象的赋值该有什么样的差别</li>
<li>新type的对象如果被passed by value，意味着什么</li>
<li>什么是新type的“合法值”</li>
<li>你的新type需要配合某个继承图系吗？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的</li>
<li>什么样的标准函数应该被驳回</li>
<li>谁该取用新type的成员</li>
<li>什么是新type的“未声明接口”</li>
<li>你的新type有多么一般化</li>
<li>你真的需要一个新type吗</li>
</ul>
<h4 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>class 的设计就是type的设计。</li>
</ul>
<h3 id="条款20：-宁以pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：-宁以pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20： 宁以pass-by-reference-to-const 替换 pass-by-value"></a>条款20： 宁以pass-by-reference-to-const 替换 pass-by-value</h3><h3 id="条款21：-必须返回对象时，别妄想返回其reference"><a href="#条款21：-必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21： 必须返回对象时，别妄想返回其reference"></a>条款21： 必须返回对象时，别妄想返回其reference</h3><h3 id="条款22：-将成员变量声明为private"><a href="#条款22：-将成员变量声明为private" class="headerlink" title="条款22： 将成员变量声明为private"></a>条款22： 将成员变量声明为private</h3><h3 id="条款23：-宁以non-member、non-friend替换-member-函数"><a href="#条款23：-宁以non-member、non-friend替换-member-函数" class="headerlink" title="条款23： 宁以non-member、non-friend替换 member 函数"></a>条款23： 宁以non-member、non-friend替换 member 函数</h3><h3 id="条款24：-若所有参数皆需类型转换，请为此采用-non-member-函数"><a href="#条款24：-若所有参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款24： 若所有参数皆需类型转换，请为此采用 non-member 函数"></a>条款24： 若所有参数皆需类型转换，请为此采用 non-member 函数</h3><h3 id="条款25：-考虑写出一个不抛异常的-swap-函数"><a href="#条款25：-考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款25： 考虑写出一个不抛异常的 swap 函数"></a>条款25： 考虑写出一个不抛异常的 swap 函数</h3><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="条款26：-尽可能延后变量定义式的出现时间"><a href="#条款26：-尽可能延后变量定义式的出现时间" class="headerlink" title="条款26： 尽可能延后变量定义式的出现时间"></a>条款26： 尽可能延后变量定义式的出现时间</h3><h3 id="条款27："><a href="#条款27：" class="headerlink" title="条款27："></a>条款27：</h3><h3 id="条款28："><a href="#条款28：" class="headerlink" title="条款28："></a>条款28：</h3><h3 id="条款29："><a href="#条款29：" class="headerlink" title="条款29："></a>条款29：</h3><h3 id="条款30："><a href="#条款30：" class="headerlink" title="条款30："></a>条款30：</h3><h3 id="条款31："><a href="#条款31：" class="headerlink" title="条款31："></a>条款31：</h3><h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="条款32："><a href="#条款32：" class="headerlink" title="条款32："></a>条款32：</h3><h3 id="条款33："><a href="#条款33：" class="headerlink" title="条款33："></a>条款33：</h3><h3 id="条款34："><a href="#条款34：" class="headerlink" title="条款34："></a>条款34：</h3><h3 id="条款35："><a href="#条款35：" class="headerlink" title="条款35："></a>条款35：</h3><h3 id="条款36："><a href="#条款36：" class="headerlink" title="条款36："></a>条款36：</h3><h3 id="条款37："><a href="#条款37：" class="headerlink" title="条款37："></a>条款37：</h3><h3 id="条款38："><a href="#条款38：" class="headerlink" title="条款38："></a>条款38：</h3><h3 id="条款39："><a href="#条款39：" class="headerlink" title="条款39："></a>条款39：</h3><h3 id="条款40："><a href="#条款40：" class="headerlink" title="条款40："></a>条款40：</h3><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="条款41："><a href="#条款41：" class="headerlink" title="条款41："></a>条款41：</h3><h3 id="条款42："><a href="#条款42：" class="headerlink" title="条款42："></a>条款42：</h3><h3 id="条款43："><a href="#条款43：" class="headerlink" title="条款43："></a>条款43：</h3><h3 id="条款44："><a href="#条款44：" class="headerlink" title="条款44："></a>条款44：</h3><h3 id="条款45："><a href="#条款45：" class="headerlink" title="条款45："></a>条款45：</h3><h3 id="条款46："><a href="#条款46：" class="headerlink" title="条款46："></a>条款46：</h3><h3 id="条款47："><a href="#条款47：" class="headerlink" title="条款47："></a>条款47：</h3><h3 id="条款48："><a href="#条款48：" class="headerlink" title="条款48："></a>条款48：</h3><h2 id="定制-new-和-delete"><a href="#定制-new-和-delete" class="headerlink" title="定制 new 和 delete"></a>定制 new 和 delete</h2><h3 id="条款49："><a href="#条款49：" class="headerlink" title="条款49："></a>条款49：</h3><h3 id="条款50："><a href="#条款50：" class="headerlink" title="条款50："></a>条款50：</h3><h3 id="条款51："><a href="#条款51：" class="headerlink" title="条款51："></a>条款51：</h3><h3 id="条款52："><a href="#条款52：" class="headerlink" title="条款52："></a>条款52：</h3><h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><h3 id="条款53："><a href="#条款53：" class="headerlink" title="条款53："></a>条款53：</h3><h3 id="条款54："><a href="#条款54：" class="headerlink" title="条款54："></a>条款54：</h3><h3 id="条款55："><a href="#条款55：" class="headerlink" title="条款55："></a>条款55：</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/学习笔记/" rel="tag"># 学习笔记</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/17/Leetcode周赛/" rel="next" title="Leetcode周赛">
                <i class="fa fa-chevron-left"></i> Leetcode周赛
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/31/分布式和云计算/" rel="prev" title="分布式和云计算(理论)">
                分布式和云计算(理论) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Austin Deng">
            
              <p class="site-author-name" itemprop="name">Austin Deng</p>
              <p class="site-description motion-element" itemprop="description">凡心所向，素履以往；生如逆旅，一苇以航。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#让自己习惯C"><span class="nav-number">1.</span> <span class="nav-text">让自己习惯C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款01：-视-C-为一个语言联邦"><span class="nav-number">1.1.</span> <span class="nav-text">条款01： 视 C++ 为一个语言联邦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款02：-尽量以-const，enum，inline-替换-define"><span class="nav-number">1.2.</span> <span class="nav-text">条款02： 尽量以 const，enum，inline 替换 #define</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#emum-hack"><span class="nav-number">1.2.1.</span> <span class="nav-text">emum hack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-define实现宏-macros"><span class="nav-number">1.2.2.</span> <span class="nav-text">使用#define实现宏(macros)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款03：-尽可能使用-const"><span class="nav-number">1.3.</span> <span class="nav-text">条款03： 尽可能使用 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const-成员函数"><span class="nav-number">1.3.1.</span> <span class="nav-text">const 成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bitwise-const"><span class="nav-number">1.3.2.</span> <span class="nav-text">bitwise const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logical-constness"><span class="nav-number">1.3.3.</span> <span class="nav-text">logical constness</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-const-和-non-const-成员函数中避免重复"><span class="nav-number">1.3.4.</span> <span class="nav-text">在 const 和 non-const 成员函数中避免重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结："><span class="nav-number">1.3.5.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款04：-确定对象被使用前已被初始化"><span class="nav-number">1.4.</span> <span class="nav-text">条款04： 确定对象被使用前已被初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不同编译单元内定义的-non-local-static-对象的初始化次序"><span class="nav-number">1.4.1.</span> <span class="nav-text">不同编译单元内定义的 non-local static 对象的初始化次序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造-析构-赋值运算"><span class="nav-number">2.</span> <span class="nav-text">构造/析构/赋值运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款05：-了解-C-默默编写并调用哪些函数"><span class="nav-number">2.1.</span> <span class="nav-text">条款05： 了解 C++ 默默编写并调用哪些函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-2"><span class="nav-number">2.1.1.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款06：-若不想使用编译器自动生成函数，就该明确拒绝"><span class="nav-number">2.2.</span> <span class="nav-text">条款06： 若不想使用编译器自动生成函数，就该明确拒绝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款07：-为多态基类声明-virtual-析构函数"><span class="nav-number">2.3.</span> <span class="nav-text">条款07： 为多态基类声明 virtual 析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#纯虚函数"><span class="nav-number">2.3.1.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款08：-别让异常逃离析构函数"><span class="nav-number">2.4.</span> <span class="nav-text">条款08： 别让异常逃离析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款09：-绝不在构造和析构过程中调用-virtual-函数"><span class="nav-number">2.5.</span> <span class="nav-text">条款09： 绝不在构造和析构过程中调用 virtual 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款10：-令-operator-返回一个-reference-to-this"><span class="nav-number">2.6.</span> <span class="nav-text">条款10： 令 operator= 返回一个 reference to *this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-5"><span class="nav-number">2.6.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款11：-在-operator-中处理“自我赋值”"><span class="nav-number">2.7.</span> <span class="nav-text">条款11： 在 operator= 中处理“自我赋值”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-6"><span class="nav-number">2.7.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款12：-复制对象时勿忘其每一个成分"><span class="nav-number">2.8.</span> <span class="nav-text">条款12： 复制对象时勿忘其每一个成分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-7"><span class="nav-number">2.8.1.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源管理"><span class="nav-number">3.</span> <span class="nav-text">资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款13：-以对象管理资源"><span class="nav-number">3.1.</span> <span class="nav-text">条款13： 以对象管理资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-8"><span class="nav-number">3.1.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款14：-在资源管理类中小心-copying-行为"><span class="nav-number">3.2.</span> <span class="nav-text">条款14： 在资源管理类中小心 copying 行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-9"><span class="nav-number">3.2.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款15：-在资源管理类中提供对原始资源的访问"><span class="nav-number">3.3.</span> <span class="nav-text">条款15： 在资源管理类中提供对原始资源的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#显式转换"><span class="nav-number">3.3.1.</span> <span class="nav-text">显式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式转换"><span class="nav-number">3.3.2.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-3"><span class="nav-number">3.3.3.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款16：-成对使用-new-和-delete-时要采取相同形式"><span class="nav-number">3.4.</span> <span class="nav-text">条款16： 成对使用 new 和 delete 时要采取相同形式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-4"><span class="nav-number">3.4.1.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款17：-以独立语句将-newed-对象置入智能指针"><span class="nav-number">3.5.</span> <span class="nav-text">条款17： 以独立语句将 newed 对象置入智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-5"><span class="nav-number">3.5.1.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计与声明"><span class="nav-number">4.</span> <span class="nav-text">设计与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款18：-让接口容易被正确使用，不易被误用"><span class="nav-number">4.1.</span> <span class="nav-text">条款18： 让接口容易被正确使用，不易被误用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-6"><span class="nav-number">4.1.1.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款19：-设计-class-犹如设计-type"><span class="nav-number">4.2.</span> <span class="nav-text">条款19： 设计 class 犹如设计 type</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结：-7"><span class="nav-number">4.2.1.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款20：-宁以pass-by-reference-to-const-替换-pass-by-value"><span class="nav-number">4.3.</span> <span class="nav-text">条款20： 宁以pass-by-reference-to-const 替换 pass-by-value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款21：-必须返回对象时，别妄想返回其reference"><span class="nav-number">4.4.</span> <span class="nav-text">条款21： 必须返回对象时，别妄想返回其reference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款22：-将成员变量声明为private"><span class="nav-number">4.5.</span> <span class="nav-text">条款22： 将成员变量声明为private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款23：-宁以non-member、non-friend替换-member-函数"><span class="nav-number">4.6.</span> <span class="nav-text">条款23： 宁以non-member、non-friend替换 member 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款24：-若所有参数皆需类型转换，请为此采用-non-member-函数"><span class="nav-number">4.7.</span> <span class="nav-text">条款24： 若所有参数皆需类型转换，请为此采用 non-member 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款25：-考虑写出一个不抛异常的-swap-函数"><span class="nav-number">4.8.</span> <span class="nav-text">条款25： 考虑写出一个不抛异常的 swap 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">5.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款26：-尽可能延后变量定义式的出现时间"><span class="nav-number">5.1.</span> <span class="nav-text">条款26： 尽可能延后变量定义式的出现时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款27："><span class="nav-number">5.2.</span> <span class="nav-text">条款27：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款28："><span class="nav-number">5.3.</span> <span class="nav-text">条款28：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款29："><span class="nav-number">5.4.</span> <span class="nav-text">条款29：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款30："><span class="nav-number">5.5.</span> <span class="nav-text">条款30：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款31："><span class="nav-number">5.6.</span> <span class="nav-text">条款31：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承与面向对象设计"><span class="nav-number">6.</span> <span class="nav-text">继承与面向对象设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款32："><span class="nav-number">6.1.</span> <span class="nav-text">条款32：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款33："><span class="nav-number">6.2.</span> <span class="nav-text">条款33：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款34："><span class="nav-number">6.3.</span> <span class="nav-text">条款34：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款35："><span class="nav-number">6.4.</span> <span class="nav-text">条款35：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款36："><span class="nav-number">6.5.</span> <span class="nav-text">条款36：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款37："><span class="nav-number">6.6.</span> <span class="nav-text">条款37：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款38："><span class="nav-number">6.7.</span> <span class="nav-text">条款38：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款39："><span class="nav-number">6.8.</span> <span class="nav-text">条款39：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款40："><span class="nav-number">6.9.</span> <span class="nav-text">条款40：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板与泛型编程"><span class="nav-number">7.</span> <span class="nav-text">模板与泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款41："><span class="nav-number">7.1.</span> <span class="nav-text">条款41：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款42："><span class="nav-number">7.2.</span> <span class="nav-text">条款42：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款43："><span class="nav-number">7.3.</span> <span class="nav-text">条款43：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款44："><span class="nav-number">7.4.</span> <span class="nav-text">条款44：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款45："><span class="nav-number">7.5.</span> <span class="nav-text">条款45：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款46："><span class="nav-number">7.6.</span> <span class="nav-text">条款46：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款47："><span class="nav-number">7.7.</span> <span class="nav-text">条款47：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款48："><span class="nav-number">7.8.</span> <span class="nav-text">条款48：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制-new-和-delete"><span class="nav-number">8.</span> <span class="nav-text">定制 new 和 delete</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款49："><span class="nav-number">8.1.</span> <span class="nav-text">条款49：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款50："><span class="nav-number">8.2.</span> <span class="nav-text">条款50：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款51："><span class="nav-number">8.3.</span> <span class="nav-text">条款51：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款52："><span class="nav-number">8.4.</span> <span class="nav-text">条款52：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杂项讨论"><span class="nav-number">9.</span> <span class="nav-text">杂项讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条款53："><span class="nav-number">9.1.</span> <span class="nav-text">条款53：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款54："><span class="nav-number">9.2.</span> <span class="nav-text">条款54：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条款55："><span class="nav-number">9.3.</span> <span class="nav-text">条款55：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Austin Deng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
